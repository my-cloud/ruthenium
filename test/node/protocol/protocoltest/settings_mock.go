// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package protocoltest

import (
	"github.com/my-cloud/ruthenium/src/node/protocol"
	"sync"
	"time"
)

// Ensure, that SettingsMock does implement Settings.
// If this is not the case, regenerate this file with moq.
var _ protocol.Settings = &SettingsMock{}

// SettingsMock is a mock implementation of Settings.
//
//	func TestSomethingThatUsesSettings(t *testing.T) {
//
//		// make and configure a mocked Settings
//		mockedSettings := &SettingsMock{
//			BlocksCountLimitFunc: func() uint64 {
//				panic("mock out the BlocksCountLimit method")
//			},
//			GenesisAmountFunc: func() uint64 {
//				panic("mock out the GenesisAmount method")
//			},
//			HalfLifeInNanosecondsFunc: func() float64 {
//				panic("mock out the HalfLifeInNanoseconds method")
//			},
//			IncomeBaseFunc: func() uint64 {
//				panic("mock out the IncomeBase method")
//			},
//			IncomeLimitFunc: func() uint64 {
//				panic("mock out the IncomeLimit method")
//			},
//			MinimalTransactionFeeFunc: func() uint64 {
//				panic("mock out the MinimalTransactionFee method")
//			},
//			ValidationTimeoutFunc: func() time.Duration {
//				panic("mock out the ValidationTimeout method")
//			},
//			ValidationTimestampFunc: func() int64 {
//				panic("mock out the ValidationTimestamp method")
//			},
//		}
//
//		// use mockedSettings in code that requires Settings
//		// and then make assertions.
//
//	}
type SettingsMock struct {
	// BlocksCountLimitFunc mocks the BlocksCountLimit method.
	BlocksCountLimitFunc func() uint64

	// GenesisAmountFunc mocks the GenesisAmount method.
	GenesisAmountFunc func() uint64

	// HalfLifeInNanosecondsFunc mocks the HalfLifeInNanoseconds method.
	HalfLifeInNanosecondsFunc func() float64

	// IncomeBaseFunc mocks the IncomeBase method.
	IncomeBaseFunc func() uint64

	// IncomeLimitFunc mocks the IncomeLimit method.
	IncomeLimitFunc func() uint64

	// MinimalTransactionFeeFunc mocks the MinimalTransactionFee method.
	MinimalTransactionFeeFunc func() uint64

	// ValidationTimeoutFunc mocks the ValidationTimeout method.
	ValidationTimeoutFunc func() time.Duration

	// ValidationTimestampFunc mocks the ValidationTimestamp method.
	ValidationTimestampFunc func() int64

	// calls tracks calls to the methods.
	calls struct {
		// BlocksCountLimit holds details about calls to the BlocksCountLimit method.
		BlocksCountLimit []struct {
		}
		// GenesisAmount holds details about calls to the GenesisAmount method.
		GenesisAmount []struct {
		}
		// HalfLifeInNanoseconds holds details about calls to the HalfLifeInNanoseconds method.
		HalfLifeInNanoseconds []struct {
		}
		// IncomeBase holds details about calls to the IncomeBase method.
		IncomeBase []struct {
		}
		// IncomeLimit holds details about calls to the IncomeLimit method.
		IncomeLimit []struct {
		}
		// MinimalTransactionFee holds details about calls to the MinimalTransactionFee method.
		MinimalTransactionFee []struct {
		}
		// ValidationTimeout holds details about calls to the ValidationTimeout method.
		ValidationTimeout []struct {
		}
		// ValidationTimestamp holds details about calls to the ValidationTimestamp method.
		ValidationTimestamp []struct {
		}
	}
	lockBlocksCountLimit      sync.RWMutex
	lockGenesisAmount         sync.RWMutex
	lockHalfLifeInNanoseconds sync.RWMutex
	lockIncomeBase            sync.RWMutex
	lockIncomeLimit           sync.RWMutex
	lockMinimalTransactionFee sync.RWMutex
	lockValidationTimeout     sync.RWMutex
	lockValidationTimestamp   sync.RWMutex
}

// BlocksCountLimit calls BlocksCountLimitFunc.
func (mock *SettingsMock) BlocksCountLimit() uint64 {
	if mock.BlocksCountLimitFunc == nil {
		panic("SettingsMock.BlocksCountLimitFunc: method is nil but Settings.BlocksCountLimit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBlocksCountLimit.Lock()
	mock.calls.BlocksCountLimit = append(mock.calls.BlocksCountLimit, callInfo)
	mock.lockBlocksCountLimit.Unlock()
	return mock.BlocksCountLimitFunc()
}

// BlocksCountLimitCalls gets all the calls that were made to BlocksCountLimit.
// Check the length with:
//
//	len(mockedSettings.BlocksCountLimitCalls())
func (mock *SettingsMock) BlocksCountLimitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBlocksCountLimit.RLock()
	calls = mock.calls.BlocksCountLimit
	mock.lockBlocksCountLimit.RUnlock()
	return calls
}

// GenesisAmount calls GenesisAmountFunc.
func (mock *SettingsMock) GenesisAmount() uint64 {
	if mock.GenesisAmountFunc == nil {
		panic("SettingsMock.GenesisAmountFunc: method is nil but Settings.GenesisAmount was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGenesisAmount.Lock()
	mock.calls.GenesisAmount = append(mock.calls.GenesisAmount, callInfo)
	mock.lockGenesisAmount.Unlock()
	return mock.GenesisAmountFunc()
}

// GenesisAmountCalls gets all the calls that were made to GenesisAmount.
// Check the length with:
//
//	len(mockedSettings.GenesisAmountCalls())
func (mock *SettingsMock) GenesisAmountCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGenesisAmount.RLock()
	calls = mock.calls.GenesisAmount
	mock.lockGenesisAmount.RUnlock()
	return calls
}

// HalfLifeInNanoseconds calls HalfLifeInNanosecondsFunc.
func (mock *SettingsMock) HalfLifeInNanoseconds() float64 {
	if mock.HalfLifeInNanosecondsFunc == nil {
		panic("SettingsMock.HalfLifeInNanosecondsFunc: method is nil but Settings.HalfLifeInNanoseconds was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHalfLifeInNanoseconds.Lock()
	mock.calls.HalfLifeInNanoseconds = append(mock.calls.HalfLifeInNanoseconds, callInfo)
	mock.lockHalfLifeInNanoseconds.Unlock()
	return mock.HalfLifeInNanosecondsFunc()
}

// HalfLifeInNanosecondsCalls gets all the calls that were made to HalfLifeInNanoseconds.
// Check the length with:
//
//	len(mockedSettings.HalfLifeInNanosecondsCalls())
func (mock *SettingsMock) HalfLifeInNanosecondsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHalfLifeInNanoseconds.RLock()
	calls = mock.calls.HalfLifeInNanoseconds
	mock.lockHalfLifeInNanoseconds.RUnlock()
	return calls
}

// IncomeBase calls IncomeBaseFunc.
func (mock *SettingsMock) IncomeBase() uint64 {
	if mock.IncomeBaseFunc == nil {
		panic("SettingsMock.IncomeBaseFunc: method is nil but Settings.IncomeBase was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIncomeBase.Lock()
	mock.calls.IncomeBase = append(mock.calls.IncomeBase, callInfo)
	mock.lockIncomeBase.Unlock()
	return mock.IncomeBaseFunc()
}

// IncomeBaseCalls gets all the calls that were made to IncomeBase.
// Check the length with:
//
//	len(mockedSettings.IncomeBaseCalls())
func (mock *SettingsMock) IncomeBaseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIncomeBase.RLock()
	calls = mock.calls.IncomeBase
	mock.lockIncomeBase.RUnlock()
	return calls
}

// IncomeLimit calls IncomeLimitFunc.
func (mock *SettingsMock) IncomeLimit() uint64 {
	if mock.IncomeLimitFunc == nil {
		panic("SettingsMock.IncomeLimitFunc: method is nil but Settings.IncomeLimit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIncomeLimit.Lock()
	mock.calls.IncomeLimit = append(mock.calls.IncomeLimit, callInfo)
	mock.lockIncomeLimit.Unlock()
	return mock.IncomeLimitFunc()
}

// IncomeLimitCalls gets all the calls that were made to IncomeLimit.
// Check the length with:
//
//	len(mockedSettings.IncomeLimitCalls())
func (mock *SettingsMock) IncomeLimitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIncomeLimit.RLock()
	calls = mock.calls.IncomeLimit
	mock.lockIncomeLimit.RUnlock()
	return calls
}

// MinimalTransactionFee calls MinimalTransactionFeeFunc.
func (mock *SettingsMock) MinimalTransactionFee() uint64 {
	if mock.MinimalTransactionFeeFunc == nil {
		panic("SettingsMock.MinimalTransactionFeeFunc: method is nil but Settings.MinimalTransactionFee was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMinimalTransactionFee.Lock()
	mock.calls.MinimalTransactionFee = append(mock.calls.MinimalTransactionFee, callInfo)
	mock.lockMinimalTransactionFee.Unlock()
	return mock.MinimalTransactionFeeFunc()
}

// MinimalTransactionFeeCalls gets all the calls that were made to MinimalTransactionFee.
// Check the length with:
//
//	len(mockedSettings.MinimalTransactionFeeCalls())
func (mock *SettingsMock) MinimalTransactionFeeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMinimalTransactionFee.RLock()
	calls = mock.calls.MinimalTransactionFee
	mock.lockMinimalTransactionFee.RUnlock()
	return calls
}

// ValidationTimeout calls ValidationTimeoutFunc.
func (mock *SettingsMock) ValidationTimeout() time.Duration {
	if mock.ValidationTimeoutFunc == nil {
		panic("SettingsMock.ValidationTimeoutFunc: method is nil but Settings.ValidationTimeout was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidationTimeout.Lock()
	mock.calls.ValidationTimeout = append(mock.calls.ValidationTimeout, callInfo)
	mock.lockValidationTimeout.Unlock()
	return mock.ValidationTimeoutFunc()
}

// ValidationTimeoutCalls gets all the calls that were made to ValidationTimeout.
// Check the length with:
//
//	len(mockedSettings.ValidationTimeoutCalls())
func (mock *SettingsMock) ValidationTimeoutCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidationTimeout.RLock()
	calls = mock.calls.ValidationTimeout
	mock.lockValidationTimeout.RUnlock()
	return calls
}

// ValidationTimestamp calls ValidationTimestampFunc.
func (mock *SettingsMock) ValidationTimestamp() int64 {
	if mock.ValidationTimestampFunc == nil {
		panic("SettingsMock.ValidationTimestampFunc: method is nil but Settings.ValidationTimestamp was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidationTimestamp.Lock()
	mock.calls.ValidationTimestamp = append(mock.calls.ValidationTimestamp, callInfo)
	mock.lockValidationTimestamp.Unlock()
	return mock.ValidationTimestampFunc()
}

// ValidationTimestampCalls gets all the calls that were made to ValidationTimestamp.
// Check the length with:
//
//	len(mockedSettings.ValidationTimestampCalls())
func (mock *SettingsMock) ValidationTimestampCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidationTimestamp.RLock()
	calls = mock.calls.ValidationTimestamp
	mock.lockValidationTimestamp.RUnlock()
	return calls
}
