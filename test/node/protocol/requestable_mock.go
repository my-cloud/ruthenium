// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package protocol

import (
	"github.com/my-cloud/ruthenium/src/api/node"
	"github.com/my-cloud/ruthenium/src/api/node/network"
	"sync"
)

// Ensure, that RequestableMock does implement Requestable.
// If this is not the case, regenerate this file with moq.
var _ network.Requestable = &RequestableMock{}

// RequestableMock is a mock implementation of Requestable.
//
// 	func TestSomethingThatUsesRequestable(t *testing.T) {
//
// 		// make and configure a mocked Requestable
// 		mockedRequestable := &RequestableMock{
// 			AddTransactionFunc: func(request TransactionRequest) error {
// 				panic("mock out the AddTransaction method")
// 			},
// 			GetAmountFunc: func(request AmountRequest) (*AmountResponse, error) {
// 				panic("mock out the GetAmount method")
// 			},
// 			GetBlocksFunc: func() ([]*BlockResponse, error) {
// 				panic("mock out the GetBlocks method")
// 			},
// 			GetTransactionsFunc: func() ([]TransactionResponse, error) {
// 				panic("mock out the GetTransactions method")
// 			},
// 			IpFunc: func() string {
// 				panic("mock out the Ip method")
// 			},
// 			MineFunc: func() error {
// 				panic("mock out the Mine method")
// 			},
// 			PortFunc: func() uint16 {
// 				panic("mock out the Port method")
// 			},
// 			SendTargetsFunc: func(request []TargetRequest) error {
// 				panic("mock out the SendTargets method")
// 			},
// 			StartMiningFunc: func() error {
// 				panic("mock out the StartMining method")
// 			},
// 			StopMiningFunc: func() error {
// 				panic("mock out the StopMining method")
// 			},
// 			TargetFunc: func() string {
// 				panic("mock out the Target method")
// 			},
// 		}
//
// 		// use mockedRequestable in code that requires Requestable
// 		// and then make assertions.
//
// 	}
type RequestableMock struct {
	// AddTransactionFunc mocks the AddTransaction method.
	AddTransactionFunc func(request node.TransactionRequest) error

	// GetAmountFunc mocks the GetAmount method.
	GetAmountFunc func(request node.AmountRequest) (*node.AmountResponse, error)

	// GetBlocksFunc mocks the GetBlocks method.
	GetBlocksFunc func() ([]*node.BlockResponse, error)

	// GetTransactionsFunc mocks the GetTransactions method.
	GetTransactionsFunc func() ([]node.TransactionResponse, error)

	// IpFunc mocks the Ip method.
	IpFunc func() string

	// MineFunc mocks the Mine method.
	MineFunc func() error

	// PortFunc mocks the Port method.
	PortFunc func() uint16

	// SendTargetsFunc mocks the SendTargets method.
	SendTargetsFunc func(request []node.TargetRequest) error

	// StartMiningFunc mocks the StartMining method.
	StartMiningFunc func() error

	// StopMiningFunc mocks the StopMining method.
	StopMiningFunc func() error

	// TargetFunc mocks the Target method.
	TargetFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// AddTransaction holds details about calls to the AddTransaction method.
		AddTransaction []struct {
			// Request is the request argument value.
			Request node.TransactionRequest
		}
		// GetAmount holds details about calls to the GetAmount method.
		GetAmount []struct {
			// Request is the request argument value.
			Request node.AmountRequest
		}
		// GetBlocks holds details about calls to the GetBlocks method.
		GetBlocks []struct {
		}
		// GetTransactions holds details about calls to the GetTransactions method.
		GetTransactions []struct {
		}
		// Ip holds details about calls to the Ip method.
		Ip []struct {
		}
		// Mine holds details about calls to the Mine method.
		Mine []struct {
		}
		// Port holds details about calls to the Port method.
		Port []struct {
		}
		// SendTargets holds details about calls to the SendTargets method.
		SendTargets []struct {
			// Request is the request argument value.
			Request []node.TargetRequest
		}
		// StartMining holds details about calls to the StartMining method.
		StartMining []struct {
		}
		// StopMining holds details about calls to the StopMining method.
		StopMining []struct {
		}
		// Target holds details about calls to the Target method.
		Target []struct {
		}
	}
	lockAddTransaction  sync.RWMutex
	lockGetAmount       sync.RWMutex
	lockGetBlocks       sync.RWMutex
	lockGetTransactions sync.RWMutex
	lockIp              sync.RWMutex
	lockMine            sync.RWMutex
	lockPort            sync.RWMutex
	lockSendTargets     sync.RWMutex
	lockStartMining     sync.RWMutex
	lockStopMining      sync.RWMutex
	lockTarget          sync.RWMutex
}

// AddTransaction calls AddTransactionFunc.
func (mock *RequestableMock) AddTransaction(request node.TransactionRequest) error {
	if mock.AddTransactionFunc == nil {
		panic("RequestableMock.AddTransactionFunc: method is nil but Requestable.AddTransaction was just called")
	}
	callInfo := struct {
		Request node.TransactionRequest
	}{
		Request: request,
	}
	mock.lockAddTransaction.Lock()
	mock.calls.AddTransaction = append(mock.calls.AddTransaction, callInfo)
	mock.lockAddTransaction.Unlock()
	return mock.AddTransactionFunc(request)
}

// AddTransactionCalls gets all the calls that were made to AddTransaction.
// Check the length with:
//     len(mockedRequestable.AddTransactionCalls())
func (mock *RequestableMock) AddTransactionCalls() []struct {
	Request node.TransactionRequest
} {
	var calls []struct {
		Request node.TransactionRequest
	}
	mock.lockAddTransaction.RLock()
	calls = mock.calls.AddTransaction
	mock.lockAddTransaction.RUnlock()
	return calls
}

// GetAmount calls GetAmountFunc.
func (mock *RequestableMock) GetAmount(request node.AmountRequest) (*node.AmountResponse, error) {
	if mock.GetAmountFunc == nil {
		panic("RequestableMock.GetAmountFunc: method is nil but Requestable.GetAmount was just called")
	}
	callInfo := struct {
		Request node.AmountRequest
	}{
		Request: request,
	}
	mock.lockGetAmount.Lock()
	mock.calls.GetAmount = append(mock.calls.GetAmount, callInfo)
	mock.lockGetAmount.Unlock()
	return mock.GetAmountFunc(request)
}

// GetAmountCalls gets all the calls that were made to GetAmount.
// Check the length with:
//     len(mockedRequestable.GetAmountCalls())
func (mock *RequestableMock) GetAmountCalls() []struct {
	Request node.AmountRequest
} {
	var calls []struct {
		Request node.AmountRequest
	}
	mock.lockGetAmount.RLock()
	calls = mock.calls.GetAmount
	mock.lockGetAmount.RUnlock()
	return calls
}

// GetBlocks calls GetBlocksFunc.
func (mock *RequestableMock) GetBlocks() ([]*node.BlockResponse, error) {
	if mock.GetBlocksFunc == nil {
		panic("RequestableMock.GetBlocksFunc: method is nil but Requestable.GetBlocks was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetBlocks.Lock()
	mock.calls.GetBlocks = append(mock.calls.GetBlocks, callInfo)
	mock.lockGetBlocks.Unlock()
	return mock.GetBlocksFunc()
}

// GetBlocksCalls gets all the calls that were made to GetBlocks.
// Check the length with:
//     len(mockedRequestable.GetBlocksCalls())
func (mock *RequestableMock) GetBlocksCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetBlocks.RLock()
	calls = mock.calls.GetBlocks
	mock.lockGetBlocks.RUnlock()
	return calls
}

// GetTransactions calls GetTransactionsFunc.
func (mock *RequestableMock) GetTransactions() ([]node.TransactionResponse, error) {
	if mock.GetTransactionsFunc == nil {
		panic("RequestableMock.GetTransactionsFunc: method is nil but Requestable.GetTransactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetTransactions.Lock()
	mock.calls.GetTransactions = append(mock.calls.GetTransactions, callInfo)
	mock.lockGetTransactions.Unlock()
	return mock.GetTransactionsFunc()
}

// GetTransactionsCalls gets all the calls that were made to GetTransactions.
// Check the length with:
//     len(mockedRequestable.GetTransactionsCalls())
func (mock *RequestableMock) GetTransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetTransactions.RLock()
	calls = mock.calls.GetTransactions
	mock.lockGetTransactions.RUnlock()
	return calls
}

// Ip calls IpFunc.
func (mock *RequestableMock) Ip() string {
	if mock.IpFunc == nil {
		panic("RequestableMock.IpFunc: method is nil but Requestable.Ip was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIp.Lock()
	mock.calls.Ip = append(mock.calls.Ip, callInfo)
	mock.lockIp.Unlock()
	return mock.IpFunc()
}

// IpCalls gets all the calls that were made to Ip.
// Check the length with:
//     len(mockedRequestable.IpCalls())
func (mock *RequestableMock) IpCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIp.RLock()
	calls = mock.calls.Ip
	mock.lockIp.RUnlock()
	return calls
}

// Mine calls MineFunc.
func (mock *RequestableMock) Mine() error {
	if mock.MineFunc == nil {
		panic("RequestableMock.MineFunc: method is nil but Requestable.Mine was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMine.Lock()
	mock.calls.Mine = append(mock.calls.Mine, callInfo)
	mock.lockMine.Unlock()
	return mock.MineFunc()
}

// MineCalls gets all the calls that were made to Mine.
// Check the length with:
//     len(mockedRequestable.MineCalls())
func (mock *RequestableMock) MineCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMine.RLock()
	calls = mock.calls.Mine
	mock.lockMine.RUnlock()
	return calls
}

// Port calls PortFunc.
func (mock *RequestableMock) Port() uint16 {
	if mock.PortFunc == nil {
		panic("RequestableMock.PortFunc: method is nil but Requestable.Port was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPort.Lock()
	mock.calls.Port = append(mock.calls.Port, callInfo)
	mock.lockPort.Unlock()
	return mock.PortFunc()
}

// PortCalls gets all the calls that were made to Port.
// Check the length with:
//     len(mockedRequestable.PortCalls())
func (mock *RequestableMock) PortCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPort.RLock()
	calls = mock.calls.Port
	mock.lockPort.RUnlock()
	return calls
}

// SendTargets calls SendTargetsFunc.
func (mock *RequestableMock) SendTargets(request []node.TargetRequest) error {
	if mock.SendTargetsFunc == nil {
		panic("RequestableMock.SendTargetsFunc: method is nil but Requestable.SendTargets was just called")
	}
	callInfo := struct {
		Request []node.TargetRequest
	}{
		Request: request,
	}
	mock.lockSendTargets.Lock()
	mock.calls.SendTargets = append(mock.calls.SendTargets, callInfo)
	mock.lockSendTargets.Unlock()
	return mock.SendTargetsFunc(request)
}

// SendTargetsCalls gets all the calls that were made to SendTargets.
// Check the length with:
//     len(mockedRequestable.SendTargetsCalls())
func (mock *RequestableMock) SendTargetsCalls() []struct {
	Request []node.TargetRequest
} {
	var calls []struct {
		Request []node.TargetRequest
	}
	mock.lockSendTargets.RLock()
	calls = mock.calls.SendTargets
	mock.lockSendTargets.RUnlock()
	return calls
}

// StartMining calls StartMiningFunc.
func (mock *RequestableMock) StartMining() error {
	if mock.StartMiningFunc == nil {
		panic("RequestableMock.StartMiningFunc: method is nil but Requestable.StartMining was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStartMining.Lock()
	mock.calls.StartMining = append(mock.calls.StartMining, callInfo)
	mock.lockStartMining.Unlock()
	return mock.StartMiningFunc()
}

// StartMiningCalls gets all the calls that were made to StartMining.
// Check the length with:
//     len(mockedRequestable.StartMiningCalls())
func (mock *RequestableMock) StartMiningCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStartMining.RLock()
	calls = mock.calls.StartMining
	mock.lockStartMining.RUnlock()
	return calls
}

// StopMining calls StopMiningFunc.
func (mock *RequestableMock) StopMining() error {
	if mock.StopMiningFunc == nil {
		panic("RequestableMock.StopMiningFunc: method is nil but Requestable.StopMining was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStopMining.Lock()
	mock.calls.StopMining = append(mock.calls.StopMining, callInfo)
	mock.lockStopMining.Unlock()
	return mock.StopMiningFunc()
}

// StopMiningCalls gets all the calls that were made to StopMining.
// Check the length with:
//     len(mockedRequestable.StopMiningCalls())
func (mock *RequestableMock) StopMiningCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStopMining.RLock()
	calls = mock.calls.StopMining
	mock.lockStopMining.RUnlock()
	return calls
}

// Target calls TargetFunc.
func (mock *RequestableMock) Target() string {
	if mock.TargetFunc == nil {
		panic("RequestableMock.TargetFunc: method is nil but Requestable.Target was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTarget.Lock()
	mock.calls.Target = append(mock.calls.Target, callInfo)
	mock.lockTarget.Unlock()
	return mock.TargetFunc()
}

// TargetCalls gets all the calls that were made to Target.
// Check the length with:
//     len(mockedRequestable.TargetCalls())
func (mock *RequestableMock) TargetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTarget.RLock()
	calls = mock.calls.Target
	mock.lockTarget.RUnlock()
	return calls
}
