// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package node

import (
	"github.com/my-cloud/ruthenium/src/network"
	"github.com/my-cloud/ruthenium/src/protocol"
	"sync"
)

// Ensure, that BlockchainMock does implement Blockchain.
// If this is not the case, regenerate this file with moq.
var _ protocol.Blockchain = &BlockchainMock{}

// BlockchainMock is a mock implementation of Blockchain.
//
// 	func TestSomethingThatUsesBlockchain(t *testing.T) {
//
// 		// make and configure a mocked Blockchain
// 		mockedBlockchain := &BlockchainMock{
// 			BlocksFunc: func() []*network.BlockResponse {
// 				panic("mock out the Blocks method")
// 			},
// 			CalculateTotalAmountFunc: func(currentTimestamp int64, blockchainAddress string) uint64 {
// 				panic("mock out the CalculateTotalAmount method")
// 			},
// 			LastBlockFunc: func() *network.BlockResponse {
// 				panic("mock out the LastBlock method")
// 			},
// 			StartVerificationFunc: func()  {
// 				panic("mock out the StartVerification method")
// 			},
// 			VerifyFunc: func()  {
// 				panic("mock out the Verify method")
// 			},
// 		}
//
// 		// use mockedBlockchain in code that requires Blockchain
// 		// and then make assertions.
//
// 	}
type BlockchainMock struct {
	// BlocksFunc mocks the Blocks method.
	BlocksFunc func() []*network.BlockResponse

	// CalculateTotalAmountFunc mocks the CalculateTotalAmount method.
	CalculateTotalAmountFunc func(currentTimestamp int64, blockchainAddress string) uint64

	// LastBlockFunc mocks the LastBlock method.
	LastBlockFunc func() *network.BlockResponse

	// StartVerificationFunc mocks the StartVerification method.
	StartVerificationFunc func()

	// VerifyFunc mocks the Verify method.
	VerifyFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Blocks holds details about calls to the Blocks method.
		Blocks []struct {
		}
		// CalculateTotalAmount holds details about calls to the CalculateTotalAmount method.
		CalculateTotalAmount []struct {
			// CurrentTimestamp is the currentTimestamp argument value.
			CurrentTimestamp int64
			// BlockchainAddress is the blockchainAddress argument value.
			BlockchainAddress string
		}
		// LastBlock holds details about calls to the LastBlock method.
		LastBlock []struct {
		}
		// StartVerification holds details about calls to the StartVerification method.
		StartVerification []struct {
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
		}
	}
	lockBlocks               sync.RWMutex
	lockCalculateTotalAmount sync.RWMutex
	lockLastBlock            sync.RWMutex
	lockStartVerification    sync.RWMutex
	lockVerify               sync.RWMutex
}

// Blocks calls BlocksFunc.
func (mock *BlockchainMock) Blocks() []*network.BlockResponse {
	if mock.BlocksFunc == nil {
		panic("BlockchainMock.BlocksFunc: method is nil but Blockchain.Blocks was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBlocks.Lock()
	mock.calls.Blocks = append(mock.calls.Blocks, callInfo)
	mock.lockBlocks.Unlock()
	return mock.BlocksFunc()
}

// BlocksCalls gets all the calls that were made to Blocks.
// Check the length with:
//     len(mockedBlockchain.BlocksCalls())
func (mock *BlockchainMock) BlocksCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBlocks.RLock()
	calls = mock.calls.Blocks
	mock.lockBlocks.RUnlock()
	return calls
}

// CalculateTotalAmount calls CalculateTotalAmountFunc.
func (mock *BlockchainMock) CalculateTotalAmount(currentTimestamp int64, blockchainAddress string) uint64 {
	if mock.CalculateTotalAmountFunc == nil {
		panic("BlockchainMock.CalculateTotalAmountFunc: method is nil but Blockchain.CalculateTotalAmount was just called")
	}
	callInfo := struct {
		CurrentTimestamp  int64
		BlockchainAddress string
	}{
		CurrentTimestamp:  currentTimestamp,
		BlockchainAddress: blockchainAddress,
	}
	mock.lockCalculateTotalAmount.Lock()
	mock.calls.CalculateTotalAmount = append(mock.calls.CalculateTotalAmount, callInfo)
	mock.lockCalculateTotalAmount.Unlock()
	return mock.CalculateTotalAmountFunc(currentTimestamp, blockchainAddress)
}

// CalculateTotalAmountCalls gets all the calls that were made to CalculateTotalAmount.
// Check the length with:
//     len(mockedBlockchain.CalculateTotalAmountCalls())
func (mock *BlockchainMock) CalculateTotalAmountCalls() []struct {
	CurrentTimestamp  int64
	BlockchainAddress string
} {
	var calls []struct {
		CurrentTimestamp  int64
		BlockchainAddress string
	}
	mock.lockCalculateTotalAmount.RLock()
	calls = mock.calls.CalculateTotalAmount
	mock.lockCalculateTotalAmount.RUnlock()
	return calls
}

// StartVerification calls StartVerificationFunc.
func (mock *BlockchainMock) StartVerification() {
	if mock.StartVerificationFunc == nil {
		panic("BlockchainMock.StartVerificationFunc: method is nil but Blockchain.StartVerification was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStartVerification.Lock()
	mock.calls.StartVerification = append(mock.calls.StartVerification, callInfo)
	mock.lockStartVerification.Unlock()
	mock.StartVerificationFunc()
}

// StartVerificationCalls gets all the calls that were made to StartVerification.
// Check the length with:
//     len(mockedBlockchain.StartVerificationCalls())
func (mock *BlockchainMock) StartVerificationCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStartVerification.RLock()
	calls = mock.calls.StartVerification
	mock.lockStartVerification.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (mock *BlockchainMock) Verify() {
	if mock.VerifyFunc == nil {
		panic("BlockchainMock.VerifyFunc: method is nil but Blockchain.Verify was just called")
	}
	callInfo := struct {
	}{}
	mock.lockVerify.Lock()
	mock.calls.Verify = append(mock.calls.Verify, callInfo)
	mock.lockVerify.Unlock()
	mock.VerifyFunc()
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//     len(mockedBlockchain.VerifyCalls())
func (mock *BlockchainMock) VerifyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockVerify.RLock()
	calls = mock.calls.Verify
	mock.lockVerify.RUnlock()
	return calls
}
