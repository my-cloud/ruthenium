// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package network

import (
	"github.com/my-cloud/ruthenium/src/api/node"
	"github.com/my-cloud/ruthenium/src/api/node/network"
	"github.com/my-cloud/ruthenium/src/api/node/protocol"
	"sync"
)

// Ensure, that ValidatableMock does implement Validatable.
// If this is not the case, regenerate this file with moq.
var _ protocol.Validatable = &ValidatableMock{}

// ValidatableMock is a mock implementation of Validatable.
//
// 	func TestSomethingThatUsesValidatable(t *testing.T) {
//
// 		// make and configure a mocked Validatable
// 		mockedValidatable := &ValidatableMock{
// 			AddTransactionFunc: func(transactionRequest *node.TransactionRequest, blockchain Verifiable, neighbors []network.Requestable)  {
// 				panic("mock out the AddTransaction method")
// 			},
// 			TransactionsFunc: func() []*node.TransactionResponse {
// 				panic("mock out the Transactions method")
// 			},
// 			ValidateFunc: func(timestamp int64, verifiable Verifiable, address string)  {
// 				panic("mock out the Validate method")
// 			},
// 		}
//
// 		// use mockedValidatable in code that requires Validatable
// 		// and then make assertions.
//
// 	}
type ValidatableMock struct {
	// AddTransactionFunc mocks the AddTransaction method.
	AddTransactionFunc func(transactionRequest *node.TransactionRequest, blockchain protocol.Verifiable, neighbors []network.Requestable)

	// TransactionsFunc mocks the Transactions method.
	TransactionsFunc func() []*node.TransactionResponse

	// ValidateFunc mocks the Validate method.
	ValidateFunc func(timestamp int64, verifiable protocol.Verifiable, address string)

	// calls tracks calls to the methods.
	calls struct {
		// AddTransaction holds details about calls to the AddTransaction method.
		AddTransaction []struct {
			// TransactionRequest is the transactionRequest argument value.
			TransactionRequest *node.TransactionRequest
			// Blockchain is the blockchain argument value.
			Blockchain protocol.Verifiable
			// Neighbors is the neighbors argument value.
			Neighbors []network.Requestable
		}
		// Transactions holds details about calls to the Transactions method.
		Transactions []struct {
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// Timestamp is the timestamp argument value.
			Timestamp int64
			// Verifiable is the verifiable argument value.
			Verifiable protocol.Verifiable
			// Address is the address argument value.
			Address string
		}
	}
	lockAddTransaction sync.RWMutex
	lockTransactions   sync.RWMutex
	lockValidate       sync.RWMutex
}

// AddTransaction calls AddTransactionFunc.
func (mock *ValidatableMock) AddTransaction(transactionRequest *node.TransactionRequest, blockchain protocol.Verifiable, neighbors []network.Requestable) {
	if mock.AddTransactionFunc == nil {
		panic("ValidatableMock.AddTransactionFunc: method is nil but Validatable.AddTransaction was just called")
	}
	callInfo := struct {
		TransactionRequest *node.TransactionRequest
		Blockchain         protocol.Verifiable
		Neighbors          []network.Requestable
	}{
		TransactionRequest: transactionRequest,
		Blockchain:         blockchain,
		Neighbors:          neighbors,
	}
	mock.lockAddTransaction.Lock()
	mock.calls.AddTransaction = append(mock.calls.AddTransaction, callInfo)
	mock.lockAddTransaction.Unlock()
	mock.AddTransactionFunc(transactionRequest, blockchain, neighbors)
}

// AddTransactionCalls gets all the calls that were made to AddTransaction.
// Check the length with:
//     len(mockedValidatable.AddTransactionCalls())
func (mock *ValidatableMock) AddTransactionCalls() []struct {
	TransactionRequest *node.TransactionRequest
	Blockchain         protocol.Verifiable
	Neighbors          []network.Requestable
} {
	var calls []struct {
		TransactionRequest *node.TransactionRequest
		Blockchain         protocol.Verifiable
		Neighbors          []network.Requestable
	}
	mock.lockAddTransaction.RLock()
	calls = mock.calls.AddTransaction
	mock.lockAddTransaction.RUnlock()
	return calls
}

// Transactions calls TransactionsFunc.
func (mock *ValidatableMock) Transactions() []*node.TransactionResponse {
	if mock.TransactionsFunc == nil {
		panic("ValidatableMock.TransactionsFunc: method is nil but Validatable.Transactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTransactions.Lock()
	mock.calls.Transactions = append(mock.calls.Transactions, callInfo)
	mock.lockTransactions.Unlock()
	return mock.TransactionsFunc()
}

// TransactionsCalls gets all the calls that were made to Transactions.
// Check the length with:
//     len(mockedValidatable.TransactionsCalls())
func (mock *ValidatableMock) TransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTransactions.RLock()
	calls = mock.calls.Transactions
	mock.lockTransactions.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *ValidatableMock) Validate(timestamp int64, verifiable protocol.Verifiable, address string) {
	if mock.ValidateFunc == nil {
		panic("ValidatableMock.ValidateFunc: method is nil but Validatable.Validate was just called")
	}
	callInfo := struct {
		Timestamp  int64
		Verifiable protocol.Verifiable
		Address    string
	}{
		Timestamp:  timestamp,
		Verifiable: verifiable,
		Address:    address,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	mock.ValidateFunc(timestamp, verifiable, address)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//     len(mockedValidatable.ValidateCalls())
func (mock *ValidatableMock) ValidateCalls() []struct {
	Timestamp  int64
	Verifiable protocol.Verifiable
	Address    string
} {
	var calls []struct {
		Timestamp  int64
		Verifiable protocol.Verifiable
		Address    string
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}
