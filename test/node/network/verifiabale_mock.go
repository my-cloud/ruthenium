// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package network

import (
	"github.com/my-cloud/ruthenium/src/api/node/network"
	"github.com/my-cloud/ruthenium/src/api/node/protocol"
	"sync"
)

// Ensure, that VerifiableMock does implement Verifiable.
// If this is not the case, regenerate this file with moq.
var _ protocol.Verifiable = &VerifiableMock{}

// VerifiableMock is a mock implementation of Verifiable.
//
// 	func TestSomethingThatUsesVerifiable(t *testing.T) {
//
// 		// make and configure a mocked Verifiable
// 		mockedVerifiable := &VerifiableMock{
// 			AddBlockFunc: func(blockResponse *network.BlockResponse)  {
// 				panic("mock out the AddBlock method")
// 			},
// 			BlocksFunc: func() []*network.BlockResponse {
// 				panic("mock out the Blocks method")
// 			},
// 			CalculateTotalAmountFunc: func(currentTimestamp int64, blockchainAddress string) uint64 {
// 				panic("mock out the CalculateTotalAmount method")
// 			},
// 			StartVerificationFunc: func(validatable Validatable, synchronizable network.Synchronizable)  {
// 				panic("mock out the StartVerification method")
// 			},
// 			VerifyFunc: func(neighbors []network.Requestable)  {
// 				panic("mock out the Verify method")
// 			},
// 		}
//
// 		// use mockedVerifiable in code that requires Verifiable
// 		// and then make assertions.
//
// 	}
type VerifiableMock struct {
	// AddBlockFunc mocks the AddBlock method.
	AddBlockFunc func(blockResponse *network.BlockResponse)

	// BlocksFunc mocks the Blocks method.
	BlocksFunc func() []*network.BlockResponse

	// CalculateTotalAmountFunc mocks the CalculateTotalAmount method.
	CalculateTotalAmountFunc func(currentTimestamp int64, blockchainAddress string) uint64

	// StartVerificationFunc mocks the StartVerification method.
	StartVerificationFunc func(validatable protocol.Validatable, synchronizable network.Synchronizable)

	// VerifyFunc mocks the Verify method.
	VerifyFunc func(neighbors []network.Requestable)

	// calls tracks calls to the methods.
	calls struct {
		// AddBlock holds details about calls to the AddBlock method.
		AddBlock []struct {
			// BlockResponse is the blockResponse argument value.
			BlockResponse *network.BlockResponse
		}
		// Blocks holds details about calls to the Blocks method.
		Blocks []struct {
		}
		// CalculateTotalAmount holds details about calls to the CalculateTotalAmount method.
		CalculateTotalAmount []struct {
			// CurrentTimestamp is the currentTimestamp argument value.
			CurrentTimestamp int64
			// BlockchainAddress is the blockchainAddress argument value.
			BlockchainAddress string
		}
		// StartVerification holds details about calls to the StartVerification method.
		StartVerification []struct {
			// Validatable is the validatable argument value.
			Validatable protocol.Validatable
			// Synchronizable is the synchronizable argument value.
			Synchronizable network.Synchronizable
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
			// Neighbors is the neighbors argument value.
			Neighbors []network.Requestable
		}
	}
	lockAddBlock             sync.RWMutex
	lockBlocks               sync.RWMutex
	lockCalculateTotalAmount sync.RWMutex
	lockStartVerification    sync.RWMutex
	lockVerify               sync.RWMutex
}

// AddBlock calls AddBlockFunc.
func (mock *VerifiableMock) AddBlock(blockResponse *network.BlockResponse) {
	if mock.AddBlockFunc == nil {
		panic("VerifiableMock.AddBlockFunc: method is nil but Verifiable.AddBlock was just called")
	}
	callInfo := struct {
		BlockResponse *network.BlockResponse
	}{
		BlockResponse: blockResponse,
	}
	mock.lockAddBlock.Lock()
	mock.calls.AddBlock = append(mock.calls.AddBlock, callInfo)
	mock.lockAddBlock.Unlock()
	mock.AddBlockFunc(blockResponse)
}

// AddBlockCalls gets all the calls that were made to AddBlock.
// Check the length with:
//     len(mockedVerifiable.AddBlockCalls())
func (mock *VerifiableMock) AddBlockCalls() []struct {
	BlockResponse *network.BlockResponse
} {
	var calls []struct {
		BlockResponse *network.BlockResponse
	}
	mock.lockAddBlock.RLock()
	calls = mock.calls.AddBlock
	mock.lockAddBlock.RUnlock()
	return calls
}

// Blocks calls BlocksFunc.
func (mock *VerifiableMock) Blocks() []*network.BlockResponse {
	if mock.BlocksFunc == nil {
		panic("VerifiableMock.BlocksFunc: method is nil but Verifiable.Blocks was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBlocks.Lock()
	mock.calls.Blocks = append(mock.calls.Blocks, callInfo)
	mock.lockBlocks.Unlock()
	return mock.BlocksFunc()
}

// BlocksCalls gets all the calls that were made to Blocks.
// Check the length with:
//     len(mockedVerifiable.BlocksCalls())
func (mock *VerifiableMock) BlocksCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBlocks.RLock()
	calls = mock.calls.Blocks
	mock.lockBlocks.RUnlock()
	return calls
}

// CalculateTotalAmount calls CalculateTotalAmountFunc.
func (mock *VerifiableMock) CalculateTotalAmount(currentTimestamp int64, blockchainAddress string) uint64 {
	if mock.CalculateTotalAmountFunc == nil {
		panic("VerifiableMock.CalculateTotalAmountFunc: method is nil but Verifiable.CalculateTotalAmount was just called")
	}
	callInfo := struct {
		CurrentTimestamp  int64
		BlockchainAddress string
	}{
		CurrentTimestamp:  currentTimestamp,
		BlockchainAddress: blockchainAddress,
	}
	mock.lockCalculateTotalAmount.Lock()
	mock.calls.CalculateTotalAmount = append(mock.calls.CalculateTotalAmount, callInfo)
	mock.lockCalculateTotalAmount.Unlock()
	return mock.CalculateTotalAmountFunc(currentTimestamp, blockchainAddress)
}

// CalculateTotalAmountCalls gets all the calls that were made to CalculateTotalAmount.
// Check the length with:
//     len(mockedVerifiable.CalculateTotalAmountCalls())
func (mock *VerifiableMock) CalculateTotalAmountCalls() []struct {
	CurrentTimestamp  int64
	BlockchainAddress string
} {
	var calls []struct {
		CurrentTimestamp  int64
		BlockchainAddress string
	}
	mock.lockCalculateTotalAmount.RLock()
	calls = mock.calls.CalculateTotalAmount
	mock.lockCalculateTotalAmount.RUnlock()
	return calls
}

// StartVerification calls StartVerificationFunc.
func (mock *VerifiableMock) StartVerification(validatable protocol.Validatable, synchronizable network.Synchronizable) {
	if mock.StartVerificationFunc == nil {
		panic("VerifiableMock.StartVerificationFunc: method is nil but Verifiable.StartVerification was just called")
	}
	callInfo := struct {
		Validatable    protocol.Validatable
		Synchronizable network.Synchronizable
	}{
		Validatable:    validatable,
		Synchronizable: synchronizable,
	}
	mock.lockStartVerification.Lock()
	mock.calls.StartVerification = append(mock.calls.StartVerification, callInfo)
	mock.lockStartVerification.Unlock()
	mock.StartVerificationFunc(validatable, synchronizable)
}

// StartVerificationCalls gets all the calls that were made to StartVerification.
// Check the length with:
//     len(mockedVerifiable.StartVerificationCalls())
func (mock *VerifiableMock) StartVerificationCalls() []struct {
	Validatable    protocol.Validatable
	Synchronizable network.Synchronizable
} {
	var calls []struct {
		Validatable    protocol.Validatable
		Synchronizable network.Synchronizable
	}
	mock.lockStartVerification.RLock()
	calls = mock.calls.StartVerification
	mock.lockStartVerification.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (mock *VerifiableMock) Verify(neighbors []network.Requestable) {
	if mock.VerifyFunc == nil {
		panic("VerifiableMock.VerifyFunc: method is nil but Verifiable.Verify was just called")
	}
	callInfo := struct {
		Neighbors []network.Requestable
	}{
		Neighbors: neighbors,
	}
	mock.lockVerify.Lock()
	mock.calls.Verify = append(mock.calls.Verify, callInfo)
	mock.lockVerify.Unlock()
	mock.VerifyFunc(neighbors)
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//     len(mockedVerifiable.VerifyCalls())
func (mock *VerifiableMock) VerifyCalls() []struct {
	Neighbors []network.Requestable
} {
	var calls []struct {
		Neighbors []network.Requestable
	}
	mock.lockVerify.RLock()
	calls = mock.calls.Verify
	mock.lockVerify.RUnlock()
	return calls
}
