// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	network2 "github.com/my-cloud/ruthenium/src/node/network"
	"github.com/my-cloud/ruthenium/src/node/protocol"
	"sync"
)

// Ensure, that TransactionsPoolMock does implement TransactionsPool.
// If this is not the case, regenerate this file with moq.
var _ protocol.TransactionsPool = &TransactionsPoolMock{}

// TransactionsPoolMock is a mock implementation of TransactionsPool.
//
// 	func TestSomethingThatUsesTransactionsPool(t *testing.T) {
//
// 		// make and configure a mocked TransactionsPool
// 		mockedTransactionsPool := &TransactionsPoolMock{
// 			AddTransactionFunc: func(transactionRequest *network.TransactionRequest, neighbors []network.Neighbor)  {
// 				panic("mock out the AddTransaction method")
// 			},
// 			TransactionsFunc: func() []*network.TransactionResponse {
// 				panic("mock out the Transactions method")
// 			},
// 		}
//
// 		// use mockedTransactionsPool in code that requires TransactionsPool
// 		// and then make assertions.
//
// 	}
type TransactionsPoolMock struct {
	// AddTransactionFunc mocks the AddTransaction method.
	AddTransactionFunc func(transactionRequest *network2.TransactionRequest, neighbors []network2.Neighbor)

	// TransactionsFunc mocks the Transactions method.
	TransactionsFunc func() []*network2.TransactionResponse

	// calls tracks calls to the methods.
	calls struct {
		// AddTransaction holds details about calls to the AddTransaction method.
		AddTransaction []struct {
			// TransactionRequest is the transactionRequest argument value.
			TransactionRequest *network2.TransactionRequest
			// Neighbors is the neighbors argument value.
			Neighbors []network2.Neighbor
		}
		// Transactions holds details about calls to the Transactions method.
		Transactions []struct {
		}
	}
	lockAddTransaction sync.RWMutex
	lockTransactions   sync.RWMutex
}

// AddTransaction calls AddTransactionFunc.
func (mock *TransactionsPoolMock) AddTransaction(transactionRequest *network2.TransactionRequest, neighbors []network2.Neighbor) {
	if mock.AddTransactionFunc == nil {
		panic("TransactionsPoolMock.AddTransactionFunc: method is nil but TransactionsPool.AddTransaction was just called")
	}
	callInfo := struct {
		TransactionRequest *network2.TransactionRequest
		Neighbors          []network2.Neighbor
	}{
		TransactionRequest: transactionRequest,
		Neighbors:          neighbors,
	}
	mock.lockAddTransaction.Lock()
	mock.calls.AddTransaction = append(mock.calls.AddTransaction, callInfo)
	mock.lockAddTransaction.Unlock()
	mock.AddTransactionFunc(transactionRequest, neighbors)
}

// AddTransactionCalls gets all the calls that were made to AddTransaction.
// Check the length with:
//     len(mockedTransactionsPool.AddTransactionCalls())
func (mock *TransactionsPoolMock) AddTransactionCalls() []struct {
	TransactionRequest *network2.TransactionRequest
	Neighbors          []network2.Neighbor
} {
	var calls []struct {
		TransactionRequest *network2.TransactionRequest
		Neighbors          []network2.Neighbor
	}
	mock.lockAddTransaction.RLock()
	calls = mock.calls.AddTransaction
	mock.lockAddTransaction.RUnlock()
	return calls
}

// Transactions calls TransactionsFunc.
func (mock *TransactionsPoolMock) Transactions() []*network2.TransactionResponse {
	if mock.TransactionsFunc == nil {
		panic("TransactionsPoolMock.TransactionsFunc: method is nil but TransactionsPool.Transactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTransactions.Lock()
	mock.calls.Transactions = append(mock.calls.Transactions, callInfo)
	mock.lockTransactions.Unlock()
	return mock.TransactionsFunc()
}

// TransactionsCalls gets all the calls that were made to Transactions.
// Check the length with:
//     len(mockedTransactionsPool.TransactionsCalls())
func (mock *TransactionsPoolMock) TransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTransactions.RLock()
	calls = mock.calls.Transactions
	mock.lockTransactions.RUnlock()
	return calls
}
