// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package network

import (
	"sync"
)

// Ensure, that NeighborsManagerMock does implement NeighborsManager.
// If this is not the case, regenerate this file with moq.
var _ NeighborsManager = &NeighborsManagerMock{}

// NeighborsManagerMock is a mock implementation of NeighborsManager.
//
//	func TestSomethingThatUsesNeighborsManager(t *testing.T) {
//
//		// make and configure a mocked NeighborsManager
//		mockedNeighborsManager := &NeighborsManagerMock{
//			AddTargetsFunc: func(targets []string)  {
//				panic("mock out the AddTargets method")
//			},
//			HostTargetFunc: func() string {
//				panic("mock out the HostTarget method")
//			},
//			IncentiveFunc: func(target string)  {
//				panic("mock out the Incentive method")
//			},
//			NeighborsFunc: func() []Neighbor {
//				panic("mock out the Neighbors method")
//			},
//		}
//
//		// use mockedNeighborsManager in code that requires NeighborsManager
//		// and then make assertions.
//
//	}
type NeighborsManagerMock struct {
	// AddTargetsFunc mocks the AddTargets method.
	AddTargetsFunc func(targets []string)

	// HostTargetFunc mocks the HostTarget method.
	HostTargetFunc func() string

	// IncentiveFunc mocks the Incentive method.
	IncentiveFunc func(target string)

	// NeighborsFunc mocks the Neighbors method.
	NeighborsFunc func() []Neighbor

	// calls tracks calls to the methods.
	calls struct {
		// AddTargets holds details about calls to the AddTargets method.
		AddTargets []struct {
			// Targets is the targets argument value.
			Targets []string
		}
		// HostTarget holds details about calls to the HostTarget method.
		HostTarget []struct {
		}
		// Incentive holds details about calls to the Incentive method.
		Incentive []struct {
			// Target is the target argument value.
			Target string
		}
		// Neighbors holds details about calls to the Neighbors method.
		Neighbors []struct {
		}
	}
	lockAddTargets sync.RWMutex
	lockHostTarget sync.RWMutex
	lockIncentive  sync.RWMutex
	lockNeighbors  sync.RWMutex
}

// AddTargets calls AddTargetsFunc.
func (mock *NeighborsManagerMock) AddTargets(targets []string) {
	if mock.AddTargetsFunc == nil {
		panic("NeighborsManagerMock.AddTargetsFunc: method is nil but NeighborsManager.AddTargets was just called")
	}
	callInfo := struct {
		Targets []string
	}{
		Targets: targets,
	}
	mock.lockAddTargets.Lock()
	mock.calls.AddTargets = append(mock.calls.AddTargets, callInfo)
	mock.lockAddTargets.Unlock()
	mock.AddTargetsFunc(targets)
}

// AddTargetsCalls gets all the calls that were made to AddTargets.
// Check the length with:
//
//	len(mockedNeighborsManager.AddTargetsCalls())
func (mock *NeighborsManagerMock) AddTargetsCalls() []struct {
	Targets []string
} {
	var calls []struct {
		Targets []string
	}
	mock.lockAddTargets.RLock()
	calls = mock.calls.AddTargets
	mock.lockAddTargets.RUnlock()
	return calls
}

// HostTarget calls HostTargetFunc.
func (mock *NeighborsManagerMock) HostTarget() string {
	if mock.HostTargetFunc == nil {
		panic("NeighborsManagerMock.HostTargetFunc: method is nil but NeighborsManager.HostTarget was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHostTarget.Lock()
	mock.calls.HostTarget = append(mock.calls.HostTarget, callInfo)
	mock.lockHostTarget.Unlock()
	return mock.HostTargetFunc()
}

// HostTargetCalls gets all the calls that were made to HostTarget.
// Check the length with:
//
//	len(mockedNeighborsManager.HostTargetCalls())
func (mock *NeighborsManagerMock) HostTargetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHostTarget.RLock()
	calls = mock.calls.HostTarget
	mock.lockHostTarget.RUnlock()
	return calls
}

// Incentive calls IncentiveFunc.
func (mock *NeighborsManagerMock) Incentive(target string) {
	if mock.IncentiveFunc == nil {
		panic("NeighborsManagerMock.IncentiveFunc: method is nil but NeighborsManager.Incentive was just called")
	}
	callInfo := struct {
		Target string
	}{
		Target: target,
	}
	mock.lockIncentive.Lock()
	mock.calls.Incentive = append(mock.calls.Incentive, callInfo)
	mock.lockIncentive.Unlock()
	mock.IncentiveFunc(target)
}

// IncentiveCalls gets all the calls that were made to Incentive.
// Check the length with:
//
//	len(mockedNeighborsManager.IncentiveCalls())
func (mock *NeighborsManagerMock) IncentiveCalls() []struct {
	Target string
} {
	var calls []struct {
		Target string
	}
	mock.lockIncentive.RLock()
	calls = mock.calls.Incentive
	mock.lockIncentive.RUnlock()
	return calls
}

// Neighbors calls NeighborsFunc.
func (mock *NeighborsManagerMock) Neighbors() []Neighbor {
	if mock.NeighborsFunc == nil {
		panic("NeighborsManagerMock.NeighborsFunc: method is nil but NeighborsManager.Neighbors was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNeighbors.Lock()
	mock.calls.Neighbors = append(mock.calls.Neighbors, callInfo)
	mock.lockNeighbors.Unlock()
	return mock.NeighborsFunc()
}

// NeighborsCalls gets all the calls that were made to Neighbors.
// Check the length with:
//
//	len(mockedNeighborsManager.NeighborsCalls())
func (mock *NeighborsManagerMock) NeighborsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNeighbors.RLock()
	calls = mock.calls.Neighbors
	mock.lockNeighbors.RUnlock()
	return calls
}
