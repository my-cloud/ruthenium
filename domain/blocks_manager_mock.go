// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package domain

import (
	"sync"
)

// Ensure, that BlocksManagerMock does implement BlocksManager.
// If this is not the case, regenerate this file with moq.
var _ BlocksManager = &BlocksManagerMock{}

// BlocksManagerMock is a mock implementation of BlocksManager.
//
//	func TestSomethingThatUsesBlocksManager(t *testing.T) {
//
//		// make and configure a mocked BlocksManager
//		mockedBlocksManager := &BlocksManagerMock{
//			AddBlockFunc: func(timestamp int64, transactionsBytes []byte, newRegisteredAddresses []string) error {
//				panic("mock out the AddBlock method")
//			},
//			BlocksFunc: func(startingBlockHeight uint64) []byte {
//				panic("mock out the Blocks method")
//			},
//			CopyFunc: func() BlocksManager {
//				panic("mock out the Copy method")
//			},
//			FirstBlockTimestampFunc: func() int64 {
//				panic("mock out the FirstBlockTimestamp method")
//			},
//			LastBlockTimestampFunc: func() int64 {
//				panic("mock out the LastBlockTimestamp method")
//			},
//			UtxoFunc: func(input InputInfoProvider) (UtxoInfoProvider, error) {
//				panic("mock out the UtxoInfoProvider method")
//			},
//			UtxosFunc: func(address string) []byte {
//				panic("mock out the Utxos method")
//			},
//		}
//
//		// use mockedBlocksManager in code that requires BlocksManager
//		// and then make assertions.
//
//	}
type BlocksManagerMock struct {
	// AddBlockFunc mocks the AddBlock method.
	AddBlockFunc func(timestamp int64, transactionsBytes []byte, newRegisteredAddresses []string) error

	// BlocksFunc mocks the Blocks method.
	BlocksFunc func(startingBlockHeight uint64) []byte

	// CopyFunc mocks the Copy method.
	CopyFunc func() BlocksManager

	// FirstBlockTimestampFunc mocks the FirstBlockTimestamp method.
	FirstBlockTimestampFunc func() int64

	// LastBlockTimestampFunc mocks the LastBlockTimestamp method.
	LastBlockTimestampFunc func() int64

	// UtxoFunc mocks the Utxo method.
	UtxoFunc func(input InputInfoProvider) (UtxoInfoProvider, error)

	// UtxosFunc mocks the Utxos method.
	UtxosFunc func(address string) []byte

	// calls tracks calls to the methods.
	calls struct {
		// AddBlock holds details about calls to the AddBlock method.
		AddBlock []struct {
			// Timestamp is the timestamp argument value.
			Timestamp int64
			// TransactionsBytes is the transactionsBytes argument value.
			TransactionsBytes []byte
			// NewRegisteredAddresses is the newRegisteredAddresses argument value.
			NewRegisteredAddresses []string
		}
		// Blocks holds details about calls to the Blocks method.
		Blocks []struct {
			// StartingBlockHeight is the startingBlockHeight argument value.
			StartingBlockHeight uint64
		}
		// Copy holds details about calls to the Copy method.
		Copy []struct {
		}
		// FirstBlockTimestamp holds details about calls to the FirstBlockTimestamp method.
		FirstBlockTimestamp []struct {
		}
		// LastBlockTimestamp holds details about calls to the LastBlockTimestamp method.
		LastBlockTimestamp []struct {
		}
		// Utxo holds details about calls to the Utxo method.
		Utxo []struct {
			// Input is the input argument value.
			Input InputInfoProvider
		}
		// Utxos holds details about calls to the Utxos method.
		Utxos []struct {
			// Address is the address argument value.
			Address string
		}
	}
	lockAddBlock            sync.RWMutex
	lockBlocks              sync.RWMutex
	lockCopy                sync.RWMutex
	lockFirstBlockTimestamp sync.RWMutex
	lockLastBlockTimestamp  sync.RWMutex
	lockUtxo                sync.RWMutex
	lockUtxos               sync.RWMutex
}

// AddBlock calls AddBlockFunc.
func (mock *BlocksManagerMock) AddBlock(timestamp int64, transactionsBytes []byte, newRegisteredAddresses []string) error {
	if mock.AddBlockFunc == nil {
		panic("BlocksManagerMock.AddBlockFunc: method is nil but BlocksManager.AddBlock was just called")
	}
	callInfo := struct {
		Timestamp              int64
		TransactionsBytes      []byte
		NewRegisteredAddresses []string
	}{
		Timestamp:              timestamp,
		TransactionsBytes:      transactionsBytes,
		NewRegisteredAddresses: newRegisteredAddresses,
	}
	mock.lockAddBlock.Lock()
	mock.calls.AddBlock = append(mock.calls.AddBlock, callInfo)
	mock.lockAddBlock.Unlock()
	return mock.AddBlockFunc(timestamp, transactionsBytes, newRegisteredAddresses)
}

// AddBlockCalls gets all the calls that were made to AddBlock.
// Check the length with:
//
//	len(mockedBlocksManager.AddBlockCalls())
func (mock *BlocksManagerMock) AddBlockCalls() []struct {
	Timestamp              int64
	TransactionsBytes      []byte
	NewRegisteredAddresses []string
} {
	var calls []struct {
		Timestamp              int64
		TransactionsBytes      []byte
		NewRegisteredAddresses []string
	}
	mock.lockAddBlock.RLock()
	calls = mock.calls.AddBlock
	mock.lockAddBlock.RUnlock()
	return calls
}

// Blocks calls BlocksFunc.
func (mock *BlocksManagerMock) Blocks(startingBlockHeight uint64) []byte {
	if mock.BlocksFunc == nil {
		panic("BlocksManagerMock.BlocksFunc: method is nil but BlocksManager.Blocks was just called")
	}
	callInfo := struct {
		StartingBlockHeight uint64
	}{
		StartingBlockHeight: startingBlockHeight,
	}
	mock.lockBlocks.Lock()
	mock.calls.Blocks = append(mock.calls.Blocks, callInfo)
	mock.lockBlocks.Unlock()
	return mock.BlocksFunc(startingBlockHeight)
}

// BlocksCalls gets all the calls that were made to Blocks.
// Check the length with:
//
//	len(mockedBlocksManager.BlocksCalls())
func (mock *BlocksManagerMock) BlocksCalls() []struct {
	StartingBlockHeight uint64
} {
	var calls []struct {
		StartingBlockHeight uint64
	}
	mock.lockBlocks.RLock()
	calls = mock.calls.Blocks
	mock.lockBlocks.RUnlock()
	return calls
}

// Copy calls CopyFunc.
func (mock *BlocksManagerMock) Copy() BlocksManager {
	if mock.CopyFunc == nil {
		panic("BlocksManagerMock.CopyFunc: method is nil but BlocksManager.Copy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCopy.Lock()
	mock.calls.Copy = append(mock.calls.Copy, callInfo)
	mock.lockCopy.Unlock()
	return mock.CopyFunc()
}

// CopyCalls gets all the calls that were made to Copy.
// Check the length with:
//
//	len(mockedBlocksManager.CopyCalls())
func (mock *BlocksManagerMock) CopyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCopy.RLock()
	calls = mock.calls.Copy
	mock.lockCopy.RUnlock()
	return calls
}

// FirstBlockTimestamp calls FirstBlockTimestampFunc.
func (mock *BlocksManagerMock) FirstBlockTimestamp() int64 {
	if mock.FirstBlockTimestampFunc == nil {
		panic("BlocksManagerMock.FirstBlockTimestampFunc: method is nil but BlocksManager.FirstBlockTimestamp was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFirstBlockTimestamp.Lock()
	mock.calls.FirstBlockTimestamp = append(mock.calls.FirstBlockTimestamp, callInfo)
	mock.lockFirstBlockTimestamp.Unlock()
	return mock.FirstBlockTimestampFunc()
}

// FirstBlockTimestampCalls gets all the calls that were made to FirstBlockTimestamp.
// Check the length with:
//
//	len(mockedBlocksManager.FirstBlockTimestampCalls())
func (mock *BlocksManagerMock) FirstBlockTimestampCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFirstBlockTimestamp.RLock()
	calls = mock.calls.FirstBlockTimestamp
	mock.lockFirstBlockTimestamp.RUnlock()
	return calls
}

// LastBlockTimestamp calls LastBlockTimestampFunc.
func (mock *BlocksManagerMock) LastBlockTimestamp() int64 {
	if mock.LastBlockTimestampFunc == nil {
		panic("BlocksManagerMock.LastBlockTimestampFunc: method is nil but BlocksManager.LastBlockTimestamp was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastBlockTimestamp.Lock()
	mock.calls.LastBlockTimestamp = append(mock.calls.LastBlockTimestamp, callInfo)
	mock.lockLastBlockTimestamp.Unlock()
	return mock.LastBlockTimestampFunc()
}

// LastBlockTimestampCalls gets all the calls that were made to LastBlockTimestamp.
// Check the length with:
//
//	len(mockedBlocksManager.LastBlockTimestampCalls())
func (mock *BlocksManagerMock) LastBlockTimestampCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastBlockTimestamp.RLock()
	calls = mock.calls.LastBlockTimestamp
	mock.lockLastBlockTimestamp.RUnlock()
	return calls
}

// UtxoInfoProvider calls UtxoFunc.
func (mock *BlocksManagerMock) Utxo(input InputInfoProvider) (UtxoInfoProvider, error) {
	if mock.UtxoFunc == nil {
		panic("BlocksManagerMock.UtxoFunc: method is nil but BlocksManager.UtxoInfoProvider was just called")
	}
	callInfo := struct {
		Input InputInfoProvider
	}{
		Input: input,
	}
	mock.lockUtxo.Lock()
	mock.calls.Utxo = append(mock.calls.Utxo, callInfo)
	mock.lockUtxo.Unlock()
	return mock.UtxoFunc(input)
}

// UtxoCalls gets all the calls that were made to UtxoInfoProvider.
// Check the length with:
//
//	len(mockedBlocksManager.UtxoCalls())
func (mock *BlocksManagerMock) UtxoCalls() []struct {
	Input InputInfoProvider
} {
	var calls []struct {
		Input InputInfoProvider
	}
	mock.lockUtxo.RLock()
	calls = mock.calls.Utxo
	mock.lockUtxo.RUnlock()
	return calls
}

// Utxos calls UtxosFunc.
func (mock *BlocksManagerMock) Utxos(address string) []byte {
	if mock.UtxosFunc == nil {
		panic("BlocksManagerMock.UtxosFunc: method is nil but BlocksManager.Utxos was just called")
	}
	callInfo := struct {
		Address string
	}{
		Address: address,
	}
	mock.lockUtxos.Lock()
	mock.calls.Utxos = append(mock.calls.Utxos, callInfo)
	mock.lockUtxos.Unlock()
	return mock.UtxosFunc(address)
}

// UtxosCalls gets all the calls that were made to Utxos.
// Check the length with:
//
//	len(mockedBlocksManager.UtxosCalls())
func (mock *BlocksManagerMock) UtxosCalls() []struct {
	Address string
} {
	var calls []struct {
		Address string
	}
	mock.lockUtxos.RLock()
	calls = mock.calls.Utxos
	mock.lockUtxos.RUnlock()
	return calls
}
