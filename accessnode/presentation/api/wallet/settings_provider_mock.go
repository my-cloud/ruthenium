// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package wallet

import (
	"sync"
)

// Ensure, that SettingsProviderMock does implement SettingsProvider.
// If this is not the case, regenerate this file with moq.
var _ SettingsProvider = &SettingsProviderMock{}

// SettingsProviderMock is a mock implementation of SettingsProvider.
//
//	func TestSomethingThatUsesSettingsProvider(t *testing.T) {
//
//		// make and configure a mocked SettingsProvider
//		mockedSettingsProvider := &SettingsProviderMock{
//			HalfLifeInNanosecondsFunc: func() float64 {
//				panic("mock out the HalfLifeInNanoseconds method")
//			},
//			IncomeBaseFunc: func() uint64 {
//				panic("mock out the IncomeBase method")
//			},
//			IncomeLimitFunc: func() uint64 {
//				panic("mock out the IncomeLimit method")
//			},
//			SmallestUnitsPerCoinFunc: func() uint64 {
//				panic("mock out the SmallestUnitsPerCoin method")
//			},
//		}
//
//		// use mockedSettingsProvider in code that requires SettingsProvider
//		// and then make assertions.
//
//	}
type SettingsProviderMock struct {
	// HalfLifeInNanosecondsFunc mocks the HalfLifeInNanoseconds method.
	HalfLifeInNanosecondsFunc func() float64

	// IncomeBaseFunc mocks the IncomeBase method.
	IncomeBaseFunc func() uint64

	// IncomeLimitFunc mocks the IncomeLimit method.
	IncomeLimitFunc func() uint64

	// SmallestUnitsPerCoinFunc mocks the SmallestUnitsPerCoin method.
	SmallestUnitsPerCoinFunc func() uint64

	// calls tracks calls to the methods.
	calls struct {
		// HalfLifeInNanoseconds holds details about calls to the HalfLifeInNanoseconds method.
		HalfLifeInNanoseconds []struct {
		}
		// IncomeBase holds details about calls to the IncomeBase method.
		IncomeBase []struct {
		}
		// IncomeLimit holds details about calls to the IncomeLimit method.
		IncomeLimit []struct {
		}
		// SmallestUnitsPerCoin holds details about calls to the SmallestUnitsPerCoin method.
		SmallestUnitsPerCoin []struct {
		}
	}
	lockHalfLifeInNanoseconds sync.RWMutex
	lockIncomeBase            sync.RWMutex
	lockIncomeLimit           sync.RWMutex
	lockSmallestUnitsPerCoin  sync.RWMutex
}

// HalfLifeInNanoseconds calls HalfLifeInNanosecondsFunc.
func (mock *SettingsProviderMock) HalfLifeInNanoseconds() float64 {
	if mock.HalfLifeInNanosecondsFunc == nil {
		panic("SettingsProviderMock.HalfLifeInNanosecondsFunc: method is nil but SettingsProvider.HalfLifeInNanoseconds was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHalfLifeInNanoseconds.Lock()
	mock.calls.HalfLifeInNanoseconds = append(mock.calls.HalfLifeInNanoseconds, callInfo)
	mock.lockHalfLifeInNanoseconds.Unlock()
	return mock.HalfLifeInNanosecondsFunc()
}

// HalfLifeInNanosecondsCalls gets all the calls that were made to HalfLifeInNanoseconds.
// Check the length with:
//
//	len(mockedSettingsProvider.HalfLifeInNanosecondsCalls())
func (mock *SettingsProviderMock) HalfLifeInNanosecondsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHalfLifeInNanoseconds.RLock()
	calls = mock.calls.HalfLifeInNanoseconds
	mock.lockHalfLifeInNanoseconds.RUnlock()
	return calls
}

// IncomeBase calls IncomeBaseFunc.
func (mock *SettingsProviderMock) IncomeBase() uint64 {
	if mock.IncomeBaseFunc == nil {
		panic("SettingsProviderMock.IncomeBaseFunc: method is nil but SettingsProvider.IncomeBase was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIncomeBase.Lock()
	mock.calls.IncomeBase = append(mock.calls.IncomeBase, callInfo)
	mock.lockIncomeBase.Unlock()
	return mock.IncomeBaseFunc()
}

// IncomeBaseCalls gets all the calls that were made to IncomeBase.
// Check the length with:
//
//	len(mockedSettingsProvider.IncomeBaseCalls())
func (mock *SettingsProviderMock) IncomeBaseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIncomeBase.RLock()
	calls = mock.calls.IncomeBase
	mock.lockIncomeBase.RUnlock()
	return calls
}

// IncomeLimit calls IncomeLimitFunc.
func (mock *SettingsProviderMock) IncomeLimit() uint64 {
	if mock.IncomeLimitFunc == nil {
		panic("SettingsProviderMock.IncomeLimitFunc: method is nil but SettingsProvider.IncomeLimit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIncomeLimit.Lock()
	mock.calls.IncomeLimit = append(mock.calls.IncomeLimit, callInfo)
	mock.lockIncomeLimit.Unlock()
	return mock.IncomeLimitFunc()
}

// IncomeLimitCalls gets all the calls that were made to IncomeLimit.
// Check the length with:
//
//	len(mockedSettingsProvider.IncomeLimitCalls())
func (mock *SettingsProviderMock) IncomeLimitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIncomeLimit.RLock()
	calls = mock.calls.IncomeLimit
	mock.lockIncomeLimit.RUnlock()
	return calls
}

// SmallestUnitsPerCoin calls SmallestUnitsPerCoinFunc.
func (mock *SettingsProviderMock) SmallestUnitsPerCoin() uint64 {
	if mock.SmallestUnitsPerCoinFunc == nil {
		panic("SettingsProviderMock.SmallestUnitsPerCoinFunc: method is nil but SettingsProvider.SmallestUnitsPerCoin was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSmallestUnitsPerCoin.Lock()
	mock.calls.SmallestUnitsPerCoin = append(mock.calls.SmallestUnitsPerCoin, callInfo)
	mock.lockSmallestUnitsPerCoin.Unlock()
	return mock.SmallestUnitsPerCoinFunc()
}

// SmallestUnitsPerCoinCalls gets all the calls that were made to SmallestUnitsPerCoin.
// Check the length with:
//
//	len(mockedSettingsProvider.SmallestUnitsPerCoinCalls())
func (mock *SettingsProviderMock) SmallestUnitsPerCoinCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSmallestUnitsPerCoin.RLock()
	calls = mock.calls.SmallestUnitsPerCoin
	mock.lockSmallestUnitsPerCoin.RUnlock()
	return calls
}
