// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package application

import (
	"github.com/my-cloud/ruthenium/validatornode/domain/protocol"
	"sync"
)

// Ensure, that UtxosManagerMock does implement UtxosManager.
// If this is not the case, regenerate this file with moq.
var _ UtxosManager = &UtxosManagerMock{}

// UtxosManagerMock is a mock implementation of UtxosManager.
//
//	func TestSomethingThatUsesUtxosManager(t *testing.T) {
//
//		// make and configure a mocked UtxosManager
//		mockedUtxosManager := &UtxosManagerMock{
//			CalculateFeeFunc: func(transaction *protocol.Transaction, timestamp int64) (uint64, error) {
//				panic("mock out the CalculateFee method")
//			},
//			ClearFunc: func()  {
//				panic("mock out the Clear method")
//			},
//			CopyFunc: func() UtxosManager {
//				panic("mock out the Copy method")
//			},
//			UpdateUtxosFunc: func(transactions []*protocol.Transaction, timestamp int64) error {
//				panic("mock out the UpdateUtxos method")
//			},
//			UtxosFunc: func(address string) []*protocol.Utxo {
//				panic("mock out the Utxos method")
//			},
//		}
//
//		// use mockedUtxosManager in code that requires UtxosManager
//		// and then make assertions.
//
//	}
type UtxosManagerMock struct {
	// CalculateFeeFunc mocks the CalculateFee method.
	CalculateFeeFunc func(transaction *protocol.Transaction, timestamp int64) (uint64, error)

	// ClearFunc mocks the Clear method.
	ClearFunc func()

	// CopyFunc mocks the Copy method.
	CopyFunc func() UtxosManager

	// UpdateUtxosFunc mocks the UpdateUtxos method.
	UpdateUtxosFunc func(transactions []*protocol.Transaction, timestamp int64) error

	// UtxosFunc mocks the Utxos method.
	UtxosFunc func(address string) []*protocol.Utxo

	// calls tracks calls to the methods.
	calls struct {
		// CalculateFee holds details about calls to the CalculateFee method.
		CalculateFee []struct {
			// Transaction is the transaction argument value.
			Transaction *protocol.Transaction
			// Timestamp is the timestamp argument value.
			Timestamp int64
		}
		// Clear holds details about calls to the Clear method.
		Clear []struct {
		}
		// Copy holds details about calls to the Copy method.
		Copy []struct {
		}
		// UpdateUtxos holds details about calls to the UpdateUtxos method.
		UpdateUtxos []struct {
			// Transactions is the transactions argument value.
			Transactions []*protocol.Transaction
			// Timestamp is the timestamp argument value.
			Timestamp int64
		}
		// Utxos holds details about calls to the Utxos method.
		Utxos []struct {
			// Address is the address argument value.
			Address string
		}
	}
	lockCalculateFee sync.RWMutex
	lockClear        sync.RWMutex
	lockCopy         sync.RWMutex
	lockUpdateUtxos  sync.RWMutex
	lockUtxos        sync.RWMutex
}

// CalculateFee calls CalculateFeeFunc.
func (mock *UtxosManagerMock) CalculateFee(transaction *protocol.Transaction, timestamp int64) (uint64, error) {
	if mock.CalculateFeeFunc == nil {
		panic("UtxosManagerMock.CalculateFeeFunc: method is nil but UtxosManager.CalculateFee was just called")
	}
	callInfo := struct {
		Transaction *protocol.Transaction
		Timestamp   int64
	}{
		Transaction: transaction,
		Timestamp:   timestamp,
	}
	mock.lockCalculateFee.Lock()
	mock.calls.CalculateFee = append(mock.calls.CalculateFee, callInfo)
	mock.lockCalculateFee.Unlock()
	return mock.CalculateFeeFunc(transaction, timestamp)
}

// CalculateFeeCalls gets all the calls that were made to CalculateFee.
// Check the length with:
//
//	len(mockedUtxosManager.CalculateFeeCalls())
func (mock *UtxosManagerMock) CalculateFeeCalls() []struct {
	Transaction *protocol.Transaction
	Timestamp   int64
} {
	var calls []struct {
		Transaction *protocol.Transaction
		Timestamp   int64
	}
	mock.lockCalculateFee.RLock()
	calls = mock.calls.CalculateFee
	mock.lockCalculateFee.RUnlock()
	return calls
}

// Clear calls ClearFunc.
func (mock *UtxosManagerMock) Clear() {
	if mock.ClearFunc == nil {
		panic("UtxosManagerMock.ClearFunc: method is nil but UtxosManager.Clear was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	mock.ClearFunc()
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//
//	len(mockedUtxosManager.ClearCalls())
func (mock *UtxosManagerMock) ClearCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// Copy calls CopyFunc.
func (mock *UtxosManagerMock) Copy() UtxosManager {
	if mock.CopyFunc == nil {
		panic("UtxosManagerMock.CopyFunc: method is nil but UtxosManager.Copy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCopy.Lock()
	mock.calls.Copy = append(mock.calls.Copy, callInfo)
	mock.lockCopy.Unlock()
	return mock.CopyFunc()
}

// CopyCalls gets all the calls that were made to Copy.
// Check the length with:
//
//	len(mockedUtxosManager.CopyCalls())
func (mock *UtxosManagerMock) CopyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCopy.RLock()
	calls = mock.calls.Copy
	mock.lockCopy.RUnlock()
	return calls
}

// UpdateUtxos calls UpdateUtxosFunc.
func (mock *UtxosManagerMock) UpdateUtxos(transactions []*protocol.Transaction, timestamp int64) error {
	if mock.UpdateUtxosFunc == nil {
		panic("UtxosManagerMock.UpdateUtxosFunc: method is nil but UtxosManager.UpdateUtxos was just called")
	}
	callInfo := struct {
		Transactions []*protocol.Transaction
		Timestamp    int64
	}{
		Transactions: transactions,
		Timestamp:    timestamp,
	}
	mock.lockUpdateUtxos.Lock()
	mock.calls.UpdateUtxos = append(mock.calls.UpdateUtxos, callInfo)
	mock.lockUpdateUtxos.Unlock()
	return mock.UpdateUtxosFunc(transactions, timestamp)
}

// UpdateUtxosCalls gets all the calls that were made to UpdateUtxos.
// Check the length with:
//
//	len(mockedUtxosManager.UpdateUtxosCalls())
func (mock *UtxosManagerMock) UpdateUtxosCalls() []struct {
	Transactions []*protocol.Transaction
	Timestamp    int64
} {
	var calls []struct {
		Transactions []*protocol.Transaction
		Timestamp    int64
	}
	mock.lockUpdateUtxos.RLock()
	calls = mock.calls.UpdateUtxos
	mock.lockUpdateUtxos.RUnlock()
	return calls
}

// Utxos calls UtxosFunc.
func (mock *UtxosManagerMock) Utxos(address string) []*protocol.Utxo {
	if mock.UtxosFunc == nil {
		panic("UtxosManagerMock.UtxosFunc: method is nil but UtxosManager.Utxos was just called")
	}
	callInfo := struct {
		Address string
	}{
		Address: address,
	}
	mock.lockUtxos.Lock()
	mock.calls.Utxos = append(mock.calls.Utxos, callInfo)
	mock.lockUtxos.Unlock()
	return mock.UtxosFunc(address)
}

// UtxosCalls gets all the calls that were made to Utxos.
// Check the length with:
//
//	len(mockedUtxosManager.UtxosCalls())
func (mock *UtxosManagerMock) UtxosCalls() []struct {
	Address string
} {
	var calls []struct {
		Address string
	}
	mock.lockUtxos.RLock()
	calls = mock.calls.Utxos
	mock.lockUtxos.RUnlock()
	return calls
}
