// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package ledger

import (
	"sync"
)

// Ensure, that TransactionsManagerMock does implement TransactionsManager.
// If this is not the case, regenerate this file with moq.
var _ TransactionsManager = &TransactionsManagerMock{}

// TransactionsManagerMock is a mock implementation of TransactionsManager.
//
//	func TestSomethingThatUsesTransactionsManager(t *testing.T) {
//
//		// make and configure a mocked TransactionsManager
//		mockedTransactionsManager := &TransactionsManagerMock{
//			AddTransactionFunc: func(transactionRequestBytes []byte, hostTarget string)  {
//				panic("mock out the AddTransaction method")
//			},
//			TransactionsFunc: func() []byte {
//				panic("mock out the Transactions method")
//			},
//		}
//
//		// use mockedTransactionsManager in code that requires TransactionsManager
//		// and then make assertions.
//
//	}
type TransactionsManagerMock struct {
	// AddTransactionFunc mocks the AddTransaction method.
	AddTransactionFunc func(transactionRequestBytes []byte, hostTarget string)

	// TransactionsFunc mocks the Transactions method.
	TransactionsFunc func() []byte

	// calls tracks calls to the methods.
	calls struct {
		// AddTransaction holds details about calls to the AddTransaction method.
		AddTransaction []struct {
			// TransactionRequestBytes is the transactionRequestBytes argument value.
			TransactionRequestBytes []byte
			// HostTarget is the hostTarget argument value.
			HostTarget string
		}
		// Transactions holds details about calls to the Transactions method.
		Transactions []struct {
		}
	}
	lockAddTransaction sync.RWMutex
	lockTransactions   sync.RWMutex
}

// AddTransaction calls AddTransactionFunc.
func (mock *TransactionsManagerMock) AddTransaction(transactionRequestBytes []byte, hostTarget string) {
	if mock.AddTransactionFunc == nil {
		panic("TransactionsManagerMock.AddTransactionFunc: method is nil but TransactionsManager.AddTransaction was just called")
	}
	callInfo := struct {
		TransactionRequestBytes []byte
		HostTarget              string
	}{
		TransactionRequestBytes: transactionRequestBytes,
		HostTarget:              hostTarget,
	}
	mock.lockAddTransaction.Lock()
	mock.calls.AddTransaction = append(mock.calls.AddTransaction, callInfo)
	mock.lockAddTransaction.Unlock()
	mock.AddTransactionFunc(transactionRequestBytes, hostTarget)
}

// AddTransactionCalls gets all the calls that were made to AddTransaction.
// Check the length with:
//
//	len(mockedTransactionsManager.AddTransactionCalls())
func (mock *TransactionsManagerMock) AddTransactionCalls() []struct {
	TransactionRequestBytes []byte
	HostTarget              string
} {
	var calls []struct {
		TransactionRequestBytes []byte
		HostTarget              string
	}
	mock.lockAddTransaction.RLock()
	calls = mock.calls.AddTransaction
	mock.lockAddTransaction.RUnlock()
	return calls
}

// Transactions calls TransactionsFunc.
func (mock *TransactionsManagerMock) Transactions() []byte {
	if mock.TransactionsFunc == nil {
		panic("TransactionsManagerMock.TransactionsFunc: method is nil but TransactionsManager.Transactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTransactions.Lock()
	mock.calls.Transactions = append(mock.calls.Transactions, callInfo)
	mock.lockTransactions.Unlock()
	return mock.TransactionsFunc()
}

// TransactionsCalls gets all the calls that were made to Transactions.
// Check the length with:
//
//	len(mockedTransactionsManager.TransactionsCalls())
func (mock *TransactionsManagerMock) TransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTransactions.RLock()
	calls = mock.calls.Transactions
	mock.lockTransactions.RUnlock()
	return calls
}
