// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package application

import (
	"sync"
)

// Ensure, that AddressesManagerMock does implement AddressesManager.
// If this is not the case, regenerate this file with moq.
var _ AddressesManager = &AddressesManagerMock{}

// AddressesManagerMock is a mock implementation of AddressesManager.
//
//	func TestSomethingThatUsesAddressesManager(t *testing.T) {
//
//		// make and configure a mocked AddressesManager
//		mockedAddressesManager := &AddressesManagerMock{
//			ClearFunc: func()  {
//				panic("mock out the Clear method")
//			},
//			CopyFunc: func() AddressesManager {
//				panic("mock out the Copy method")
//			},
//			FilterFunc: func(addresses []string) []string {
//				panic("mock out the Filter method")
//			},
//			IsRegisteredFunc: func(address string) bool {
//				panic("mock out the IsRegistered method")
//			},
//			RemovedAddressesFunc: func() []string {
//				panic("mock out the RemovedAddresses method")
//			},
//			UpdateFunc: func(addedAddresses []string, removedAddresses []string)  {
//				panic("mock out the Update method")
//			},
//			VerifyFunc: func(addedAddresses []string, removedAddresses []string) error {
//				panic("mock out the Verify method")
//			},
//		}
//
//		// use mockedAddressesManager in code that requires AddressesManager
//		// and then make assertions.
//
//	}
type AddressesManagerMock struct {
	// ClearFunc mocks the Clear method.
	ClearFunc func()

	// CopyFunc mocks the Copy method.
	CopyFunc func() AddressesManager

	// FilterFunc mocks the Filter method.
	FilterFunc func(addresses []string) []string

	// IsRegisteredFunc mocks the IsRegistered method.
	IsRegisteredFunc func(address string) bool

	// RemovedAddressesFunc mocks the RemovedAddresses method.
	RemovedAddressesFunc func() []string

	// UpdateFunc mocks the Update method.
	UpdateFunc func(addedAddresses []string, removedAddresses []string)

	// VerifyFunc mocks the Verify method.
	VerifyFunc func(addedAddresses []string, removedAddresses []string) error

	// calls tracks calls to the methods.
	calls struct {
		// Clear holds details about calls to the Clear method.
		Clear []struct {
		}
		// Copy holds details about calls to the Copy method.
		Copy []struct {
		}
		// Filter holds details about calls to the Filter method.
		Filter []struct {
			// Addresses is the addresses argument value.
			Addresses []string
		}
		// IsRegistered holds details about calls to the IsRegistered method.
		IsRegistered []struct {
			// Address is the address argument value.
			Address string
		}
		// RemovedAddresses holds details about calls to the RemovedAddresses method.
		RemovedAddresses []struct {
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// AddedAddresses is the addedAddresses argument value.
			AddedAddresses []string
			// RemovedAddresses is the removedAddresses argument value.
			RemovedAddresses []string
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
			// AddedAddresses is the addedAddresses argument value.
			AddedAddresses []string
			// RemovedAddresses is the removedAddresses argument value.
			RemovedAddresses []string
		}
	}
	lockClear            sync.RWMutex
	lockCopy             sync.RWMutex
	lockFilter           sync.RWMutex
	lockIsRegistered     sync.RWMutex
	lockRemovedAddresses sync.RWMutex
	lockUpdate           sync.RWMutex
	lockVerify           sync.RWMutex
}

// Clear calls ClearFunc.
func (mock *AddressesManagerMock) Clear() {
	if mock.ClearFunc == nil {
		panic("AddressesManagerMock.ClearFunc: method is nil but AddressesManager.Clear was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	mock.ClearFunc()
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//
//	len(mockedAddressesManager.ClearCalls())
func (mock *AddressesManagerMock) ClearCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// Copy calls CopyFunc.
func (mock *AddressesManagerMock) Copy() AddressesManager {
	if mock.CopyFunc == nil {
		panic("AddressesManagerMock.CopyFunc: method is nil but AddressesManager.Copy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCopy.Lock()
	mock.calls.Copy = append(mock.calls.Copy, callInfo)
	mock.lockCopy.Unlock()
	return mock.CopyFunc()
}

// CopyCalls gets all the calls that were made to Copy.
// Check the length with:
//
//	len(mockedAddressesManager.CopyCalls())
func (mock *AddressesManagerMock) CopyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCopy.RLock()
	calls = mock.calls.Copy
	mock.lockCopy.RUnlock()
	return calls
}

// Filter calls FilterFunc.
func (mock *AddressesManagerMock) Filter(addresses []string) []string {
	if mock.FilterFunc == nil {
		panic("AddressesManagerMock.FilterFunc: method is nil but AddressesManager.Filter was just called")
	}
	callInfo := struct {
		Addresses []string
	}{
		Addresses: addresses,
	}
	mock.lockFilter.Lock()
	mock.calls.Filter = append(mock.calls.Filter, callInfo)
	mock.lockFilter.Unlock()
	return mock.FilterFunc(addresses)
}

// FilterCalls gets all the calls that were made to Filter.
// Check the length with:
//
//	len(mockedAddressesManager.FilterCalls())
func (mock *AddressesManagerMock) FilterCalls() []struct {
	Addresses []string
} {
	var calls []struct {
		Addresses []string
	}
	mock.lockFilter.RLock()
	calls = mock.calls.Filter
	mock.lockFilter.RUnlock()
	return calls
}

// IsRegistered calls IsRegisteredFunc.
func (mock *AddressesManagerMock) IsRegistered(address string) bool {
	if mock.IsRegisteredFunc == nil {
		panic("AddressesManagerMock.IsRegisteredFunc: method is nil but AddressesManager.IsRegistered was just called")
	}
	callInfo := struct {
		Address string
	}{
		Address: address,
	}
	mock.lockIsRegistered.Lock()
	mock.calls.IsRegistered = append(mock.calls.IsRegistered, callInfo)
	mock.lockIsRegistered.Unlock()
	return mock.IsRegisteredFunc(address)
}

// IsRegisteredCalls gets all the calls that were made to IsRegistered.
// Check the length with:
//
//	len(mockedAddressesManager.IsRegisteredCalls())
func (mock *AddressesManagerMock) IsRegisteredCalls() []struct {
	Address string
} {
	var calls []struct {
		Address string
	}
	mock.lockIsRegistered.RLock()
	calls = mock.calls.IsRegistered
	mock.lockIsRegistered.RUnlock()
	return calls
}

// RemovedAddresses calls RemovedAddressesFunc.
func (mock *AddressesManagerMock) RemovedAddresses() []string {
	if mock.RemovedAddressesFunc == nil {
		panic("AddressesManagerMock.RemovedAddressesFunc: method is nil but AddressesManager.RemovedAddresses was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemovedAddresses.Lock()
	mock.calls.RemovedAddresses = append(mock.calls.RemovedAddresses, callInfo)
	mock.lockRemovedAddresses.Unlock()
	return mock.RemovedAddressesFunc()
}

// RemovedAddressesCalls gets all the calls that were made to RemovedAddresses.
// Check the length with:
//
//	len(mockedAddressesManager.RemovedAddressesCalls())
func (mock *AddressesManagerMock) RemovedAddressesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemovedAddresses.RLock()
	calls = mock.calls.RemovedAddresses
	mock.lockRemovedAddresses.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *AddressesManagerMock) Update(addedAddresses []string, removedAddresses []string) {
	if mock.UpdateFunc == nil {
		panic("AddressesManagerMock.UpdateFunc: method is nil but AddressesManager.Update was just called")
	}
	callInfo := struct {
		AddedAddresses   []string
		RemovedAddresses []string
	}{
		AddedAddresses:   addedAddresses,
		RemovedAddresses: removedAddresses,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	mock.UpdateFunc(addedAddresses, removedAddresses)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedAddressesManager.UpdateCalls())
func (mock *AddressesManagerMock) UpdateCalls() []struct {
	AddedAddresses   []string
	RemovedAddresses []string
} {
	var calls []struct {
		AddedAddresses   []string
		RemovedAddresses []string
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (mock *AddressesManagerMock) Verify(addedAddresses []string, removedAddresses []string) error {
	if mock.VerifyFunc == nil {
		panic("AddressesManagerMock.VerifyFunc: method is nil but AddressesManager.Verify was just called")
	}
	callInfo := struct {
		AddedAddresses   []string
		RemovedAddresses []string
	}{
		AddedAddresses:   addedAddresses,
		RemovedAddresses: removedAddresses,
	}
	mock.lockVerify.Lock()
	mock.calls.Verify = append(mock.calls.Verify, callInfo)
	mock.lockVerify.Unlock()
	return mock.VerifyFunc(addedAddresses, removedAddresses)
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//
//	len(mockedAddressesManager.VerifyCalls())
func (mock *AddressesManagerMock) VerifyCalls() []struct {
	AddedAddresses   []string
	RemovedAddresses []string
} {
	var calls []struct {
		AddedAddresses   []string
		RemovedAddresses []string
	}
	mock.lockVerify.RLock()
	calls = mock.calls.Verify
	mock.lockVerify.RUnlock()
	return calls
}
