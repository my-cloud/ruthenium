// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package protocol

import (
	"sync"
)

// Ensure, that BlocksManagerMock does implement BlocksManager.
// If this is not the case, regenerate this file with moq.
var _ BlocksManager = &BlocksManagerMock{}

// BlocksManagerMock is a mock implementation of BlocksManager.
//
//	func TestSomethingThatUsesBlocksManager(t *testing.T) {
//
//		// make and configure a mocked BlocksManager
//		mockedBlocksManager := &BlocksManagerMock{
//			AddBlockFunc: func(timestamp int64, transactionsBytes []byte, newRegisteredAddresses []string) error {
//				panic("mock out the AddBlock method")
//			},
//			BlocksFunc: func(startingBlockHeight uint64) []byte {
//				panic("mock out the Blocks method")
//			},
//			FirstBlockTimestampFunc: func() int64 {
//				panic("mock out the FirstBlockTimestamp method")
//			},
//			LastBlockTimestampFunc: func() int64 {
//				panic("mock out the LastBlockTimestamp method")
//			},
//			LastBlockTransactionsFunc: func() []byte {
//				panic("mock out the LastBlockTransactions method")
//			},
//		}
//
//		// use mockedBlocksManager in code that requires BlocksManager
//		// and then make assertions.
//
//	}
type BlocksManagerMock struct {
	// AddBlockFunc mocks the AddBlock method.
	AddBlockFunc func(timestamp int64, transactionsBytes []byte, newRegisteredAddresses []string) error

	// BlocksFunc mocks the Blocks method.
	BlocksFunc func(startingBlockHeight uint64) []byte

	// FirstBlockTimestampFunc mocks the FirstBlockTimestamp method.
	FirstBlockTimestampFunc func() int64

	// LastBlockTimestampFunc mocks the LastBlockTimestamp method.
	LastBlockTimestampFunc func() int64

	// LastBlockTransactionsFunc mocks the LastBlockTransactions method.
	LastBlockTransactionsFunc func() []byte

	// calls tracks calls to the methods.
	calls struct {
		// AddBlock holds details about calls to the AddBlock method.
		AddBlock []struct {
			// Timestamp is the timestamp argument value.
			Timestamp int64
			// TransactionsBytes is the transactionsBytes argument value.
			TransactionsBytes []byte
			// NewRegisteredAddresses is the newRegisteredAddresses argument value.
			NewRegisteredAddresses []string
		}
		// Blocks holds details about calls to the Blocks method.
		Blocks []struct {
			// StartingBlockHeight is the startingBlockHeight argument value.
			StartingBlockHeight uint64
		}
		// FirstBlockTimestamp holds details about calls to the FirstBlockTimestamp method.
		FirstBlockTimestamp []struct {
		}
		// LastBlockTimestamp holds details about calls to the LastBlockTimestamp method.
		LastBlockTimestamp []struct {
		}
		// LastBlockTransactions holds details about calls to the LastBlockTransactions method.
		LastBlockTransactions []struct {
		}
	}
	lockAddBlock              sync.RWMutex
	lockBlocks                sync.RWMutex
	lockFirstBlockTimestamp   sync.RWMutex
	lockLastBlockTimestamp    sync.RWMutex
	lockLastBlockTransactions sync.RWMutex
}

// AddBlock calls AddBlockFunc.
func (mock *BlocksManagerMock) AddBlock(timestamp int64, transactionsBytes []byte, newRegisteredAddresses []string) error {
	if mock.AddBlockFunc == nil {
		panic("BlocksManagerMock.AddBlockFunc: method is nil but BlocksManager.AddBlock was just called")
	}
	callInfo := struct {
		Timestamp              int64
		TransactionsBytes      []byte
		NewRegisteredAddresses []string
	}{
		Timestamp:              timestamp,
		TransactionsBytes:      transactionsBytes,
		NewRegisteredAddresses: newRegisteredAddresses,
	}
	mock.lockAddBlock.Lock()
	mock.calls.AddBlock = append(mock.calls.AddBlock, callInfo)
	mock.lockAddBlock.Unlock()
	return mock.AddBlockFunc(timestamp, transactionsBytes, newRegisteredAddresses)
}

// AddBlockCalls gets all the calls that were made to AddBlock.
// Check the length with:
//
//	len(mockedBlocksManager.AddBlockCalls())
func (mock *BlocksManagerMock) AddBlockCalls() []struct {
	Timestamp              int64
	TransactionsBytes      []byte
	NewRegisteredAddresses []string
} {
	var calls []struct {
		Timestamp              int64
		TransactionsBytes      []byte
		NewRegisteredAddresses []string
	}
	mock.lockAddBlock.RLock()
	calls = mock.calls.AddBlock
	mock.lockAddBlock.RUnlock()
	return calls
}

// Blocks calls BlocksFunc.
func (mock *BlocksManagerMock) Blocks(startingBlockHeight uint64) []byte {
	if mock.BlocksFunc == nil {
		panic("BlocksManagerMock.BlocksFunc: method is nil but BlocksManager.Blocks was just called")
	}
	callInfo := struct {
		StartingBlockHeight uint64
	}{
		StartingBlockHeight: startingBlockHeight,
	}
	mock.lockBlocks.Lock()
	mock.calls.Blocks = append(mock.calls.Blocks, callInfo)
	mock.lockBlocks.Unlock()
	return mock.BlocksFunc(startingBlockHeight)
}

// BlocksCalls gets all the calls that were made to Blocks.
// Check the length with:
//
//	len(mockedBlocksManager.BlocksCalls())
func (mock *BlocksManagerMock) BlocksCalls() []struct {
	StartingBlockHeight uint64
} {
	var calls []struct {
		StartingBlockHeight uint64
	}
	mock.lockBlocks.RLock()
	calls = mock.calls.Blocks
	mock.lockBlocks.RUnlock()
	return calls
}

// FirstBlockTimestamp calls FirstBlockTimestampFunc.
func (mock *BlocksManagerMock) FirstBlockTimestamp() int64 {
	if mock.FirstBlockTimestampFunc == nil {
		panic("BlocksManagerMock.FirstBlockTimestampFunc: method is nil but BlocksManager.FirstBlockTimestamp was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFirstBlockTimestamp.Lock()
	mock.calls.FirstBlockTimestamp = append(mock.calls.FirstBlockTimestamp, callInfo)
	mock.lockFirstBlockTimestamp.Unlock()
	return mock.FirstBlockTimestampFunc()
}

// FirstBlockTimestampCalls gets all the calls that were made to FirstBlockTimestamp.
// Check the length with:
//
//	len(mockedBlocksManager.FirstBlockTimestampCalls())
func (mock *BlocksManagerMock) FirstBlockTimestampCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFirstBlockTimestamp.RLock()
	calls = mock.calls.FirstBlockTimestamp
	mock.lockFirstBlockTimestamp.RUnlock()
	return calls
}

// LastBlockTimestamp calls LastBlockTimestampFunc.
func (mock *BlocksManagerMock) LastBlockTimestamp() int64 {
	if mock.LastBlockTimestampFunc == nil {
		panic("BlocksManagerMock.LastBlockTimestampFunc: method is nil but BlocksManager.LastBlockTimestamp was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastBlockTimestamp.Lock()
	mock.calls.LastBlockTimestamp = append(mock.calls.LastBlockTimestamp, callInfo)
	mock.lockLastBlockTimestamp.Unlock()
	return mock.LastBlockTimestampFunc()
}

// LastBlockTimestampCalls gets all the calls that were made to LastBlockTimestamp.
// Check the length with:
//
//	len(mockedBlocksManager.LastBlockTimestampCalls())
func (mock *BlocksManagerMock) LastBlockTimestampCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastBlockTimestamp.RLock()
	calls = mock.calls.LastBlockTimestamp
	mock.lockLastBlockTimestamp.RUnlock()
	return calls
}

// LastBlockTransactions calls LastBlockTransactionsFunc.
func (mock *BlocksManagerMock) LastBlockTransactions() []byte {
	if mock.LastBlockTransactionsFunc == nil {
		panic("BlocksManagerMock.LastBlockTransactionsFunc: method is nil but BlocksManager.LastBlockTransactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastBlockTransactions.Lock()
	mock.calls.LastBlockTransactions = append(mock.calls.LastBlockTransactions, callInfo)
	mock.lockLastBlockTransactions.Unlock()
	return mock.LastBlockTransactionsFunc()
}

// LastBlockTransactionsCalls gets all the calls that were made to LastBlockTransactions.
// Check the length with:
//
//	len(mockedBlocksManager.LastBlockTransactionsCalls())
func (mock *BlocksManagerMock) LastBlockTransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastBlockTransactions.RLock()
	calls = mock.calls.LastBlockTransactions
	mock.lockLastBlockTransactions.RUnlock()
	return calls
}
