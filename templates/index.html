<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wallet</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/elliptic-es@0.0.1/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.0.0/core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.0.0/sha256.min.js"></script>
<body>
<div>
    <h1>Wallet</h1>
    <table>
        <tr>
            <td><label for="private_key">Private Key:</label></td>
            <td><textarea id="private_key" rows="1" cols="80" name="private_key"></textarea></td>
        </tr>
        <tr>
            <td><label for="public_key">Public Key:</label></td>
            <td><textarea disabled id="public_key" rows="2" cols="80" name="public_key"></textarea></td>
        </tr>
        <tr>
            <td><label for="sender_address">Address:</label></td>
            <td><textarea disabled id="sender_address" rows="1" cols="80" name="sender_address"></textarea></td>
        </tr>
        <tr>
            <td>
                <div>Amount:</div>
            </td>
            <td>
                <div id="wallet_amount"></div>
            </td>
        </tr>
    </table>
</div>

<div>
    <h1>Send Money</h1>
    <table>
        <tr>
            <td><label for="recipient_address">To address:</label></td>
            <td><textarea id="recipient_address" rows="1" cols="80" name="recipient_address"></textarea></td>
        </tr>
        <tr>
            <td><label for="send_amount">Amount:</label></td>
            <td><input id="send_amount" type="text" name="send_amount"></td>
        </tr>
    </table>
    <button id="send_money_button">Send</button>
</div>

<div>
    <h1>Transactions Pool</h1>
    <pre id="transactions_pool"></pre>
</div>
</body>
<script>
    const curve = "secp256k1";
    const encoding = "hex";
    const hexPrefix = "0x";
    let keyPair
    let publicKeyString
    document.getElementById("private_key").addEventListener("input", event => {
        const privateKeyString = event.target.value.toString();
        const $publicKey = $("#public_key");
        if (!privateKeyString) {
            keyPair = null;
            $publicKey.val("");
            $("#sender_address").val("");
            return
        }
        keyPair = elliptic.ec(curve).keyFromPrivate(privateKeyString.substring(2), encoding);
        publicKeyString = hexPrefix + keyPair.getPublic(encoding);
        $publicKey.val(publicKeyString);
        $.ajax({
            url: "/wallet/address",
            type: "GET",
            data: {"publicKey": publicKeyString},
            success: function (response) {
                $("#sender_address").val(response);
            },
            error: function (error) {
                console.error(error);
            }
        })

    });

    $(function () {
        $("#send_money_button").click(function () {
            if (!keyPair) {
                alert("The private key must be provided to send money")
                return
            }

            const senderAddress = $("#sender_address").val();
            const atoms = $("#send_amount").val();
            const result = atomsToParticles(atoms, 100000000);
            if (result.err) {
                alert(result.err);
                return
            }
            let value = result.particles;
            const data = {"address": senderAddress, "value": value};

            function send(response) {
                let inputs = [];
                for (let i = 0; i < response.utxos.length; i++) {
                    let utxo = response.utxos[i];
                    const hash = CryptoJS.SHA256(JSON.stringify(utxo)).toString(CryptoJS.enc.Hex);
                    const signature = keyPair.sign(hash);
                    const signatureHex = getSignatureHex(signature);
                    inputs[i] = {
                        "output_index": utxo.output_index,
                        "transaction_id": utxo.transaction_id,
                        "public_key": publicKeyString,
                        "signature": signatureHex,
                    };
                }

                const recipientAddress = $("#recipient_address").val();
                const spend = {
                    "address": recipientAddress,
                    "block_height": response.block_height,
                    "has_reward": false,
                    "has_income": false,
                    "value": value,
                }
                const rest = {
                    "address": senderAddress,
                    "block_height": response.block_height,
                    "has_reward": false,
                    "has_income": true,
                    "value": response.rest,
                }
                const dateNow = Math.floor(Date.now() * 1000000);
                const transactionRequest = {
                    "inputs": inputs,
                    "outputs": [spend, rest],
                    "timestamp": dateNow,
                };

                $.ajax({
                    url: "/transaction",
                    type: "POST",
                    contentType: "application/json",
                    data: JSON.stringify(transactionRequest),
                    success: function (response) {
                        if (response === "success") {
                            alert("Send success");
                        } else {
                            alert("Send failed: " + response)
                        }
                    },
                    error: function (response) {
                        console.error(response);
                        alert("Send failed");
                    }
                })
            }

            $.ajax({
                url: "/wallet/utxos",
                type: "GET",
                contentType: "application/json",
                dataType: 'json',
                data: data,
                success: function (response) {
                    if (!confirm("Are you sure to send?")) {
                        alert("Canceled");
                        return
                    }
                    send(response);
                },
                error: function (error) {
                    console.error(error);
                    alert("Send failed");
                }
            })
        })

        setInterval(refresh_amount, 1000)
        setInterval(refresh_transactions, 1000)

        function refresh_amount() {
            const $walletAmount = $("#wallet_amount");
            const address = $("#sender_address").val();
            if (!address) {
                $walletAmount.text(0)
                return
            }
            const data = {"address": address}
            $.ajax({
                url: "/wallet/amount",
                type: "GET",
                data: data,
                success: function (response) {
                    $walletAmount.text(response);
                },
                error: function (error) {
                    console.error(error)
                }
            })
        }

        function refresh_transactions() {
            $.ajax({
                url: "/transactions",
                type: "GET",
                success: function (response) {
                    $("#transactions_pool").text(JSON.stringify(response, undefined, 4));
                },
                error: function (error) {
                    console.error(error)
                }
            })
        }
    })

    function atomsToParticles(atoms, particlesInOneAtom) {
        const decimalSeparator = ".";
        const i = atoms.indexOf(decimalSeparator);

        if (i > 12 || (i === -1 && atoms.length > 12)) {
            return {
                particles: null,
                err: new Error("transaction value is too big")
            };
        }

        if (i >= 0) {
            const unitsString = atoms.slice(0, i);
            const units = parseInt(unitsString, 10);

            if (isNaN(units)) {
                return {
                    particles: null,
                    err: new Error("Failed to parse units")
                };
            }

            const decimalsString = atoms.slice(i + 1);
            const trailingZerosCount =
                (particlesInOneAtom.toString().length - 1) - decimalsString.length;

            if (trailingZerosCount < 0) {
                return {
                    particles: null,
                    err: new Error("transaction value is too small")
                };
            }

            const trailedDecimalsString = `${decimalsString}${"0".repeat(trailingZerosCount)}`;
            const decimals = parseInt(trailedDecimalsString, 10);

            if (isNaN(decimals)) {
                return {
                    particles: null,
                    err: new Error("Failed to parse decimals")
                };
            }

            return {
                particles: units * particlesInOneAtom + decimals,
                err: null
            };
        } else {
            const units = parseInt(atoms, 10);

            if (isNaN(units)) {
                return {
                    particles: null,
                    err: new Error("Failed to parse units")
                };
            }

            return {
                particles: units * particlesInOneAtom,
                err: null
            };
        }
    }

    function getSignatureHex(signature) {
        let rHex = signature.r.toString(encoding);
        while (rHex.length < 64) {
            rHex = "0" + rHex;
        }
        let sHex = signature.s.toString(encoding);
        while (sHex.length < 64) {
            sHex = "0" + sHex;
        }
        return rHex + sHex;
    }
</script>
</html>